;;;; apex.lisp

(in-package #:apex)

(defclass idiom ()
  ((name :accessor idiom-name
	 :initarg :name)
   (environment :accessor idiom-environment
		:initarg :environment)
   (parsers :accessor idiom-parsers
	    :initform ""
	    :initarg :function-matcher)
   (functions :accessor idiom-functions
	      :initform nil
	      :initarg :functions)
   (operators :accessor idiom-operators
	      :initform nil
	      :initarg :operators)
   (operational-glyphs :accessor idiom-opglyphs
		       :initform nil
		       :initarg :operational-glyphs)
   (operator-index :accessor idiom-opindex
		   :initform nil
		   :initarg :operator-index)
   (overloaded-lexicon :accessor idiom-overloaded-lexicon
		       :initform nil
		       :initarg :overloaded-lexicon)))

(defgeneric of-environment (idiom property))
(defmethod of-environment ((idiom idiom) property)
  (getf (idiom-environment idiom) property))

(defun handle-argument (operation omega &optional alpha)
  (if (and (symbolp (first operation))
	   (macro-function (first operation))
	   (not (eql 'lambda (first operation))))
      (cond ((eql 'args (first operation))
	     (macroexpand (append (cons 'args (last operation))
				  (cons (second operation)
					(append (if (keywordp (third operation))
						    (list (third operation))
						    ;; the placeholder is added in case of (args :scalar ...)
						    ;; and other macros which have two arguments but only one
						    ;; structure-specifying parameter
						    (if alpha (list :placeholder)))
						(if (keywordp (fourth operation))
						    (list (fourth operation))))))))
	    (t (macroexpand (append operation (cons omega (if alpha (list alpha)))))))
      `(quote ,operation)))

(defmacro ambivalent (operation second-operation &optional third-input)
  `((if alpha
	,(handle-argument (if (eq :symmetric-scalar operation)
			      (list 'args :scalar second-operation)
			      (if (eq :asymmetric-scalar operation)
				  (list 'args :scalar third-input)
				  second-operation))
			  'omega 'alpha)
	,(handle-argument (if (eq :symmetric-scalar operation)
			      (list 'args :scalar second-operation)
			      (if (eq :asymmetric-scalar operation)
				  (list 'args :scalar second-operation)
				  operation))
			  'omega))))

(defmacro monadic (operation)
  `((if alpha
	`(progn (error "Valence error - monadic operation."))
	,(handle-argument operation 'omega))))

(defmacro dyadic (operation)
  `((if alpha
	,(handle-argument operation 'omega 'alpha)
	`(error "Valence error - dyadic operation."))))

(defmacro args (operation omega &optional alpha axes)
  "Moderate arguments to a Vex function at compile time."
  (let ((fn (if (and (listp operation)
		     (macro-function (first operation))
		     (not (eql 'lambda (first operation))))
		(macroexpand (append operation (if alpha (list 'omega 'alpha)
						   (list 'omega))))
		``(function ,',operation))))
    (if (eq omega :scalar)
	`(if alpha
	     `(apply-scalar-function ,,fn ,(macroexpand omega)
				     ,(macroexpand alpha))
	     `(aops:each ,,fn ,(macroexpand omega)))
	``(if (and ,(if (eq :any ,omega)
			t (cond ((eq :one ,omega)
				 `(is-singleton ,(macroexpand omega)))
				((eq :sym ,omega)
				 (if (eql 'lambda (first alpha))
				     (setf (gethash :functions meta)
				 	   (cons (macroexpand omega)
						 (gethash :functions meta))))
				 `(symbolp (quote ,(if (listp (macroexpand omega))
						       (second (getf (macroexpand omega)
								     :initial-contents))
						       (macroexpand omega)))))))
		   ,@(if (and ,alpha (not (eq :any ,alpha)))
			 (if (eq :one ,alpha)
			     (list `(is-singleton ,(macroexpand alpha))))))
	      ;; if the arguments are scalar (:one), remove them from their arrays for evaluation
	      (funcall ,,fn ,(cond ((eq :one ,omega)
				    `(if (arrayp ,(macroexpand omega))
					 (aref ,(macroexpand omega) 0)
					 ,(macroexpand omega)))
				   ((eq :sym ,omega)
				    `(quote ,(if (listp (macroexpand omega))
						 (second (getf (macroexpand omega)
							       :initial-contents))
						 (macroexpand omega))))
				   (t (macroexpand omega)))
		       ,@(if ,alpha (list (cond ((eq :one ,alpha)
						 `(aref ,(macroexpand alpha) 0))
						((eq :axes ,alpha)
						 (cons 'list (macroexpand axes)))
						;; alpha is equal to :axes when
						;; axes are used for a monadic function
						(t (macroexpand alpha)))))
		       ,@(if ,axes (list (cons 'list (macroexpand axes)))))))))

(defmacro boolean-op (operation omega &optional alpha)
  "Converts output of a boolean operation from t/nil to 1/0."
  `(lambda ,(if alpha (list omega alpha)
  		(list omega))
     (if (funcall (function ,operation)
  		  ,@(if alpha (list omega alpha)
  			(list omega)))
  	 1 0)))

(defmacro vex-spec (symbol &rest subspecs)
  "Process the specification for a vector language and build functions that generate the code tree."
  (labels ((process-function-definition (is-dyadic is-scalar function-spec)
	     (let ((discrete-function (if (and (listp (first function-spec))
					       (macro-function (caar function-spec))
					       (not (eql 'lambda (caar function-spec))))
					  (macroexpand (append (first function-spec)
							       (cons 'omega (if is-dyadic (list 'alpha)))))
					  (cons 'function function-spec))))
	       (if (not is-scalar)
		   discrete-function
		   `(lambda ,(if is-dyadic (list 'alpha 'omega)
				 (list 'omega))
		      ,(if is-dyadic `(apply-scalar-function ,discrete-function alpha omega)
			   `(if (arrayp omega)
				(aops:each ,discrete-function omega)
				(funcall ,discrete-function omega)))))))

	   (assign-discrete-functions (entry)
	     ;; return a list containing the function, or both functions if ambivalent
	     (let ((spec (third entry)))
	       (if (eql 'monadic (first spec))
		   (list (process-function-definition nil (eq :scalar (cadadr spec))
						      (last (first (last spec)))))
		   (if (eql 'dyadic (first spec))
		       (list (process-function-definition t (eq :scalar (cadadr spec))
							  (last (first (last spec)))))
		       (list (if (listp (second spec))
				 (process-function-definition nil (or (eq :symmetric-scalar (second spec))
								      (eq :scalar (cadadr spec)))
							      (last (second spec)))
				 (process-function-definition
				  nil t
				  (if (eq :symmetric-scalar (second spec))
				      (last spec)
				      (list (third spec)))))
			     (if (listp (second spec))
				 (process-function-definition t (eq :scalar (second (third spec)))
							      (last (third spec)))
				 (process-function-definition t (or (eq :symmetric-scalar
									(second spec))
								    (eq :asymmetric-scalar
									(second spec)))
							      (last spec))))))))

	   (process-pairs (table-symbol pairs &optional output)
	     (if pairs
		 (process-pairs table-symbol (rest pairs)
				(let* ((glyph-char (character (caar pairs)))
				       (accumulator (third output)))
				  (if (and (eql 'op-specs table-symbol))
				      (setf (getf accumulator (intern (string-upcase (first (third (first pairs))))
								      "KEYWORD"))
					    (cons 'list (cons glyph-char (rest (getf accumulator
										     (intern (string-upcase
											      (first (third (first
													     pairs))))
											     "KEYWORD")))))))
				  (list (cons glyph-char (first output))
					(append (second output)
						(cond ((and (eql 'fn-specs table-symbol)
						      	    (eql 'symbolic (first (third (first pairs)))))
						       ;; assign symbolic functions as just keywords in the table
						       `((gethash ,glyph-char ,table-symbol)
						      	 ,(second (third (first pairs)))))
						      ;; assign functions in hash table
						      ((eql 'fn-specs table-symbol)
						       `((gethash ,glyph-char ,table-symbol)
							 (list (lambda (meta axes omega &optional alpha)
								 (declare (ignorable meta axes alpha))
								 ,@(macroexpand (third (first pairs))))
							       ,@(assign-discrete-functions (first pairs)))))
						      ;; assign operators in hash table
						      ((eql 'op-specs table-symbol)
						       `((gethash ,glyph-char ,table-symbol)
						      	 ,(if (eql 'macro (first (second (third (first pairs)))))
						      	      (macroexpand (second (second (third (first pairs)))))
						      	      `(lambda (meta axes functions operand
						      			&optional right-operand)
						      		 (declare (ignorable meta axes right-operand))
								 ;;(print (list functions operand))
						      		 `(funcall ,',(second (third (first pairs)))
						      			   ,(cons 'list axes)
						      			   ,(if (listp (first functions))
						      				(cons 'list
						      				      (mapcar (lambda (f)
						      						(if (listp f)
						      						    (cons 'list
						      							  (rest f))
						      						    f))
						      					      functions))
						      			   	(cons 'list (cdar functions)))
						      			   ,operand
						      			   ,@(if right-operand
						      				 (list right-operand)))))))))
					
					accumulator)))
		 output))

	   (process-tests (specs &optional output)
	     (let* ((tests (rest (assoc (intern "TESTS" (package-name *package*))
					(rest (first specs)))))
		    (props (rest (assoc (intern "HAS" (package-name *package*))
					(rest (first specs)))))
		    (heading (format nil "[~a] ~a~a"
				     (caar specs)
				     (if (getf props :title)
					 (getf props :title)
					 (if (getf props :titles)
					     (first (getf props :titles))))
				     (if (getf props :titles)
					 (concatenate 'string " / " (second (getf props :titles)))
					 ""))))
	       (labels ((for-tests (tests &optional output)
			  (if tests
			      (for-tests (rest tests)
					 (append output (list (cond ((eql 'is (caar tests))
								     `(is (,(intern (string-upcase symbol)
										    (package-name *package*))
									    ,(cadar tests))
									  ,(third (first tests))))))))
			      output)))
		 
		 (if specs
		     (process-tests (rest specs)
				    (if (assoc (intern "TESTS" (package-name *package*))
					       (rest (first specs)))
					(append output (list `(princ ,heading))
						(for-tests tests)
						(list `(princ (format nil "~%~%")) nil))
					output))
		     output)))))
    (let* ((function-specs (process-pairs 'fn-specs (rest (assoc (intern "FUNCTIONS" (package-name *package*))
								 subspecs))))
	   (operator-specs (process-pairs 'op-specs (rest (assoc (intern "OPERATORS" (package-name *package*))
								 subspecs))))
	   (function-tests (process-tests (rest (assoc (intern "FUNCTIONS" (package-name *package*))
						       subspecs))))
	   (operator-tests (process-tests (rest (assoc (intern "OPERATORS" (package-name *package*))
						       subspecs)))))
      `(progn (defvar *vex-idiom*)
	      (let ((fn-specs (make-hash-table))
		    (op-specs (make-hash-table)))
		(setf ,@(second function-specs)
		      ,@(second operator-specs))
		(setq *vex-idiom* (make-instance 'idiom
						 :name ,(intern (string-upcase symbol) "KEYWORD")
						 :environment ,(cons 'list
								     (rest (assoc (intern "ENVIRONMENT"
											  (package-name *package*))
										  subspecs)))
						 :operational-glyphs (list ,@(derive-opglyphs
									      (append (first function-specs)
										      (first operator-specs))))
						 :functions fn-specs
						 :operators op-specs
						 :overloaded-lexicon (list ,@(intersection (first function-specs)
											   (first operator-specs)))
						 :operator-index (list ,@(third operator-specs))))

		(defmacro ,(intern (string-upcase symbol)
				   (package-name *package*))
		    (options &optional input-string)
		  (if (eq :test options)
		      (cons 'progn ',(append operator-tests function-tests))
		      (vex-program *vex-idiom*
				   (if (or input-string (and options (listp options)))
				       options)
				   (if input-string input-string options)))))))))
  
(defun derive-opglyphs (glyph-list &optional output)
  (if (not glyph-list)
      output (derive-opglyphs (rest glyph-list)
			      (let ((glyph (first glyph-list)))
				(if (characterp glyph)
				    (cons glyph output)
				    (if (stringp glyph)
					(append output (loop for char from 0 to (1- (length glyph))
							  collect (aref glyph char)))))))))

(defun numeric-string-p (string)
  (handler-case (progn (parse-apl-number-string string) t)
    (condition () nil)))

(defun parse-apl-number-string (number-string &optional imaginary-component)
  (let ((nstring (string-upcase number-string)))
    (if (and (not imaginary-component)
	     (find #\J nstring))
	(let ((halves (cl-ppcre:split "J" nstring)))
	  (if (and (= 2 (length halves))
		   (< 0 (length (first halves)))
		   (< 0 (length (second halves))))
	      (complex (parse-apl-number-string (first halves) t)
		       (parse-apl-number-string (second halves) t))))
	;; either the macron or combining_macron character may be used as the high minus sign
	(parse-number:parse-number (regex-replace-all "[¯̄]" nstring "-")))))

(defun format-array (values)
  (if (or (stringp (first values))
	  (symbolp (first values))
	  (and (not (second values))
	       (or (listp (first values))
		   (functionp (first values)))))
      ;; if the first item is a list (i.e. code to generate an array of some kind),
      ;; pass it through with no changes. Also pass through strings, which are already arrays,
      ;; any symbols
      (first values)
      `(make-array (list ,(length values))
		   :initial-contents (list ,@values))))

(defun format-function (content)
  `(lambda (⍺ &optional ⍵)
     ;; kludge to handle reversing the variable order
     ;; the latter variable is always the optional one in Lisp, but in APL
     ;; the ⍺ is the optional argument
     (if ⍵ (funcall (lambda (⍺ ⍵) ,content) ⍵ ⍺)
	   (funcall (lambda (⍵) ,content) ⍺))))

(defun format-value (element)
  (cond ((and (vectorp element)
	      (string= element "⍬")) ;; APL's "zilde" character translates to an empty vector
 	 (make-array (list 0)))
	((numeric-string-p element)
	 (parse-apl-number-string element))
	((or (and (char= #\" (aref element 0))
		  (char= #\" (aref element (1- (length element)))))
	     (and (char= #\' (aref element 0))
		  (char= #\' (aref element (1- (length element))))))
	 (subseq element 1 (1- (length element))))
	((stringp element)
	 (intern (string-upcase (symbol-munger:camel-case->lisp-name element))))
	(t element)))

(defun swap! (v i j)
  (let ((tt (aref v i)))
    (setf (aref v i)
	  (aref v j))
    (setf (aref v j) tt)))

(defun reverse! (v lo hi)
  (when (< lo hi)
    (swap! v lo hi)
    (reverse! v (+ lo 1) (- hi 1))))

(defun rotate! (n v)
  (let* ((len (length v))
	 (n (mod n len)))
    (reverse! v 0 (- n 1))
    (reverse! v n (- len 1))
    (reverse! v 0 (- len 1))))

(defun make-rotator (&optional degrees)
  (lambda (vector)
    (if degrees (rotate! degrees vector)
	(reverse! vector 0 (1- (length vector))))))

(defun rot-left(n l)
  (append (nthcdr n l) (butlast l (- (length l) n))))

(defun rot-right(n l)
  (rot-left (- (length l) n) l))

(defun rotate-array-horizontal (array &optional degrees)
  (let* ((adims (dims array))
	 (new-array (alexandria:copy-array array))
	 (axis-length (if (second adims) (second adims) (first adims))))
    (dotimes (index (if (second adims) (first adims) 1))
      (let ((displaced-array (make-array (list axis-length)
					 :displaced-to new-array
					 :displaced-index-offset (* index axis-length))))
	(if degrees (rotate! degrees displaced-array)
	    (reverse! displaced-array 0 (1- axis-length)))))
    new-array))

(defun rotate-array-vertical (array &optional degrees)
  (let* ((adims (dims array))
	 (axis-length (second adims))
	 (axis-height (first adims))
	 (row-list (make-array (list axis-height) :initial-contents (alexandria:iota axis-height)))
	 (new-array (alexandria:copy-array array)))
    (if degrees (rotate! degrees row-list)
	(reverse! row-list 0 (1- axis-height)))
    (dotimes (index (1- axis-height))
      (dotimes (sub-index (1- axis-length))
	(setf (aref new-array index sub-index)
	      (aref array (aref row-list index)
		    sub-index))))
    new-array))

(defun reshape-array-fitting (array adims)
  (let* ((original-length (array-total-size array))
	 (total-length (apply #'* adims))
	 (displaced-array (make-array (list original-length) :displaced-to array)))
    (aops:reshape (make-array (list total-length)
			      :initial-contents (loop for index from 0 to (1- total-length)
						   collect (aref displaced-array (mod index original-length))))
		  adims)))

(defun sprfact (n) ; recursive factorial-computing function based on P. Luschny's code
  (let ((p 1) (r 1) (NN 1) (log2n (floor (log n 2)))
	(h 0) (shift 0) (high 1) (len 0))
    (labels ((prod (n)
	       (declare (fixnum n))
	       (let ((m (ash n -1)))
		 (cond ((= m 0) (incf NN 2))
		       ((= n 2) (* (incf NN 2)
				   (incf NN 2)))
		       (t (* (prod (- n m))
			     (prod m)))))))
      (loop while (/= h n) do
	   (incf shift h)
	   (setf h (ash n (- log2n)))
	   (decf log2n)
	   (setf len high)
	   (setf high (if (oddp h)
			  h (1- h)))
	   (setf len (ash (- high len) -1))
	   (cond ((> len 0)
		  (setf p (* p (prod len)))
		  (setf r (* r p)))))
      (ash r shift))))

(defun binomial (k n)
  (labels ((prod-enum (s e)
	     (do ((i s (1+ i)) (r 1 (* i r))) ((> i e) r)))
	   (sprfact (n) (prod-enum 1 n)))
    (/ (prod-enum (- (1+ n) k) n) (sprfact k))))

(defun is-singleton (value)
  (let ((adims (dims value)))
    (and (= 1 (first adims))
	 (= 1 (length adims)))))

(defun scale-array (singleton to-match)
  (make-array (dims to-match)
	      :initial-element (aref singleton 0)))

(defun apply-scalar-function (function alpha omega)
  (let* ((alpha-scalar? (not (arrayp alpha)))
	 (omega-scalar? (not (arrayp omega)))
	 (alpha-unitary? (and (not alpha-scalar?)
			      (vectorp alpha)
			      (= 1 (length alpha))))
	 (omega-unitary? (and (not omega-scalar?)
			      (vectorp omega)
			      (= 1 (length omega)))))
    (cond ((and alpha-scalar? omega-scalar?)
	   (funcall function alpha omega))
	  ((and alpha-unitary? omega-unitary?)
	   (aops:each (lambda (alpha omega) (apply-scalar-function function alpha omega))
		      alpha omega))
	  ((and (not alpha-unitary?)
		(not omega-unitary?)
		(not alpha-scalar?)
		(not omega-scalar?))
	   (if (loop for dimension in (funcall (lambda (a o) (mapcar #'= a o))
					       (dims alpha)
					       (dims omega))
		  always dimension)
	       (aops:each (lambda (alpha omega) (apply-scalar-function function alpha omega))
			  alpha omega)
	       (error "Array size mismatch.")))
	  (t (labels ((scan-over (element)
			(if (arrayp element)
			    (aops:each #'scan-over element)
			    (apply (lambda (left right) (apply-scalar-function function left right))
				   (cond (alpha-scalar? (list alpha element))
					 (alpha-unitary? (list (aref alpha 0)
							       element))
					 (omega-scalar? (list element omega))
					 (omega-unitary? (list element (aref omega 0))))))))
	       (aops:each #'scan-over (if (or alpha-scalar? alpha-unitary?)
					  omega alpha)))))))

(defun array-match (alpha omega)
  (let ((singleton-alpha (is-singleton alpha))
	(singleton-omega (is-singleton omega)))
    (if (or singleton-alpha singleton-omega
	    (loop for dimension in (funcall (lambda (a o) (mapcar #'= a o))
					    (dims alpha)
					    (dims omega))
	       always dimension))
	(if singleton-alpha
	    (if singleton-omega
		(list alpha omega)
		(list (scale-array alpha omega)
		      omega))
	    (if singleton-omega
		(list alpha (scale-array omega alpha))
		(list alpha omega))))))

(defun array-depth (array &optional layer)
  (let ((layer (if layer layer 1)))
    (aops:each (lambda (item)
		 (if (arrayp item)
		     (setq layer (array-depth item (1+ layer)))))
	       array)
    layer))

(defun array-to-list (array)
  "Convert array to list."
  (let* ((dimensions (dims array))
         (depth (1- (length dimensions)))
         (indices (make-list (1+ depth) :initial-element 0)))
    (labels ((recurse (n)
               (loop for j below (nth n dimensions)
		  do (setf (nth n indices) j)
		  collect (if (= n depth)
			      (apply #'aref array indices)
			      (recurse (1+ n))))))
      (recurse 0))))

(vex-spec
 apex
 (environment :count-from 1
	      :atomic-vector
	      (concatenate 'string "!\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`"
			   "abcdefghijklmnopqrstuvwxyz{|}~¥€⇄∧∼≬⋆⋸⌸⌺⌼⌾⍁¡⍣⍅⎕⍞⌹⍆⍤⍇⍈⍊⊤λ⍍⍏£⊥⍶⌶⍐⍑χ≢⍖⍗"
			   "⍘⍚⍛⌈⍜⍢∪⍨⍕⍎⍬⍪∣│┤⍟∆∇→╣║╗╝←⌊┐└┴┬├─┼↑↓╔╚╩╦╠═╬≡⍸⍷∵⌷⍂⌻⊢⊣◊┘┌█▄▌▐▀"
			   "⍺⍹⊂⊃⍝⍲⍴⍱⌽⊖○∨⍳⍉∈∩⌿⍀≥≤≠×÷⍙∘⍵⍫⍋⍒¯¨"))
 (operators (/ (has :title "Reduce")
	       (right (lambda (axes functions operand)
			(let ((new-array (copy-array operand)))
			  (if (= 1 (rank operand))
			      (make-array (list 1) :initial-element (reduce (first (last (first functions)))
									    operand))
			      (aops:margin (lambda (sub-array) (reduce (first (last (first functions)))
								       sub-array))
					   new-array (if axes (1- (aref (first axes) 0))
							 (1- (rank operand))))))))
	       (tests (is "+/1 2 3 4 5" #(15))
		      (is "+/3 4⍴⍳12" #(10 26 42))
		      (is "+/[1]3 4⍴⍳12" #(15 18 21 24))))
  	    (⌿ (has :title "Reduce First")
	       (right (lambda (axes functions operand)
			(let ((new-array (copy-array operand)))
			  (if (= 1 (rank operand))
			      (make-array (list 1) :initial-element (reduce (first (last (first functions)))
									    operand))
			      (aops:margin (lambda (sub-array) (reduce (first (last (first functions)))
								       sub-array))
					   new-array (if axes (1- (aref (first axes) 0))
							 0))))))
	       (tests (is "+⌿3 4⍴⍳12" #(15 18 21 24))))
	    (\\ (has :title "Scan")
		(right (lambda (axes functions operand)
			 (if (vectorp operand)
			     (funcall (make-back-scanner (first (last (first functions))))
 				      operand)
			     (if (arrayp operand)
				 (apply-marginal (make-back-scanner (first (last (first functions))))
						 operand (if axes (1- (aref (first axes) 0)))
						 (1- (rank operand)))))))
		(tests (is "+\\1 2 3 4 5" #(1 3 6 10 15))
		       (is "+\\3 4⍴⍳12" #2A((1 3 6 10) (5 11 18 26) (9 19 30 42)))))
	    (⍀ (has :title "Scan First")
	       (right (lambda (axes functions operand)
			(if (vectorp operand)
			    (funcall (make-back-scanner (first (last (first functions))))
				     operand)
			    (if (arrayp operand)
				(apply-marginal (make-back-scanner (first (last (first functions))))
						operand (if axes (1- (aref (first axes) 0)))
						0)))))
	       (tests (is "+⍀1 2 3 4 5" #(1 3 6 10 15))
		      (is "+⍀3 4⍴⍳12" #2A((1 2 3 4) (6 8 10 12) (15 18 21 24)))))
	    (\. (has :title "Inner/Outer Product")
		(center (lambda (axes functions operand right-operand)
			  (declare (ignore axes))
			  (if (eq :outer-product-designator (second functions))
			      (aops:outer (first (last (first functions)))
					  operand right-operand)
			      (if (and (vectorp operand)
				       (vectorp right-operand))
				  ;; NOTE: this is a hack and has problems,
				  ;; how to better control for the type of argument?
				  (make-array (list 1)
					      :initial-element
					      (reduce (first (last (second functions)))
						      (aops:each (first (last (first functions)))
								 right-operand operand)))
				  (array-inner-product operand right-operand
						       (first (last (first functions)))
						       (first (last (second functions))))))))
		(tests (is "2 3 4+.×8 15 21" #(145))
		       (is "4 5 6∘.+20 30 40 50" #2A((24 34 44 54) (25 35 45 55) (26 36 46 56)))))
            ;; ¨ must be escaped to be correctly processed
	    (\¨ (has :title "Each")
		(right (macro (lambda (meta axes functions operand &optional right-operand)
				(declare (ignore meta axes))
				(let ((placeholder nil))
				  (if right-operand (setq placeholder operand
							  operand right-operand
							  right-operand placeholder))
				  `(let ((new-array (alexandria:copy-array ,operand)))
				     (if ,right-operand
					 ;; (apply-scalar-function ,(first (last (first functions)))
					 ;; 			      ,right-operand
					 ;; 			      (make-array (dims ,right-operand)
					 ;; 					  :initial-element (aref new-array 0)))
					 (make-array (dims ,right-operand)
						     :initial-contents
						     (loop for index from 0 to (1- (length ,right-operand))
							collect (funcall ,(first (last (first functions)))
									 (aref ,right-operand index)
									 (aref new-array 0))))
					 (aops:each ,(caar functions) new-array)))))))
		(tests (is "1 ¯1 ⌽¨⊂1 2 3 4 5" #(#(2 3 4 5 1) #(5 1 2 3 4)))))
	   (⍨ (has :title "Commute")
	      (right (macro (lambda (meta axes functions operand &optional right-operand)
			      (funcall (caar functions)
				       meta axes (if right-operand right-operand operand)
				       operand))))
	      (tests (is "5-⍨10" #(5))))
	   (∘ (has :title "Composition")
	      (center (macro (lambda (meta axes functions operand &optional right-operand)
			       (declare (ignore meta axes))
			       (if (and (first functions)
					(second functions))
				   (if right-operand
				       `(apply-scalar-function ,(third (second functions))
							       ,operand (aops:each ,(second (first functions))
										   ,right-operand))
				       `(aops:each ,(cadadr functions)
						   (aops:each ,(cadar functions)
							      ,operand)))))))))
 (functions (← (has :title "Assign")
	       (dyadic (args :sym :any set)))
	    (⊣ (has :title "Left")
	       (ambivalent (args :any (lambda (omega)
					(declare (ignore omega))
					(make-array (list 0))))
			   (args :any :any (lambda (alpha omega)
					     (declare (ignore omega))
					     alpha))))
	    (⊢ (has :title "Right")
	       (ambivalent (args :any (lambda (omega) omega))
			   (args :any :any (lambda (alpha omega)
					     (declare (ignore alpha))
					     omega))))
	    (+ (has :titles ("Identity" "Add"))
	       (ambivalent :asymmetric-scalar (lambda (omega) (if (complexp omega)
								  (complex (realpart omega)
									   (- (imagpart omega)))
								  omega))
			   +)
	       (tests (is "1+1" #(2))
		      (is "1+1 2 3" #(2 3 4))))
    	    (- (has :titles ("Negate" "Subtract"))
	       (ambivalent :symmetric-scalar -)
	       (tests (is "2-1" #(1))))
     	    (× (has :titles ("Sign" "Multiply"))
	       (ambivalent :asymmetric-scalar signum *)
	       (tests (is "2×3" #(6))
		      (is "4 5×8 9" #(32 45))))
     	    (÷ (has :titles ("Reciprocal" "Divide"))
	       (ambivalent :symmetric-scalar /)
	       (tests (is "6÷2" #(3))
		      (is "12÷6 3 2" #(2 4 6))))
     	    (⋆ (has :titles ("Exponential" "Power"))
	       (ambivalent :asymmetric-scalar exp expt))
     	    (* (has :titles ("Exponential" "Power"))
	       (ambivalent :asymmetric-scalar exp expt))
     	    (⍟ (has :titles ("Natural Logarithm" "Logarithm"))
	       (ambivalent :symmetric-scalar log))
     	    (\| (has :titles ("Magnitude" "Residue"))
		(ambivalent :asymmetric-scalar abs (lambda (alpha omega) (mod omega alpha))))
     	    (! (has :titles ("Factorial" "Binomial"))
	       (ambivalent :asymmetric-scalar sprfact binomial))
     	    (⌈ (has :titles ("Ceiling" "Maximum"))
	       (ambivalent :asymmetric-scalar ceiling max))
     	    (⌊ (has :titles ("Floor" "Minimum"))
	       (ambivalent :asymmetric-scalar floor min))
	    (? (has :titles ("Random" "Deal"))
	       (ambivalent (args :scalar (lambda (omega) (+ (of-environment *vex-idiom* :count-from)
							    (random omega))))
			   (args :one :one (lambda (alpha omega)
					     (make-array (list alpha)
							 :initial-contents
							 (loop for i from 0 to (1- alpha)
							    collect (+ (of-environment *vex-idiom* :count-from)
								       (random omega))))))))
     	    (○ (has :titles ("Pi Times" "Circular"))
	       (ambivalent (args :scalar (lambda (omega) (* pi omega)))
			   (args :one :any (lambda (alpha omega)
					     (let ((fn (vector (lambda (input) (* input (exp #C(0 1))))
							       (lambda (input) (* input #C(0 1)))
							       (lambda (input) (if (complexp input)
										   (complex (realpart input)
											    (- (imagpart input)))
										   input))
							       (lambda (input) input)
							       (lambda (input) (expt (- -1 (* 2 input))
										     1/2))
							       #'atanh #'acosh #'asinh
							       (lambda (input) (* (expt (/ (1+ input) (1- input))
											1/2)
										  (1+ input)))
							       #'atan #'acos #'asin
							       (lambda (input) (expt (- 1 (* 2 input))
										     1/2))
							       #'sin #'cos #'tan
							       (lambda (input) (expt (1+ (* 2 input))
										     1/2))
							       #'sinh #'cosh #'tanh
							       (lambda (input) (expt (- -1 (* 2 input))
										     1/2))
							       #'realpart #'abs #'imagpart #'phase)))
					       ;; the twelfth element of the vector corresponds to
					       ;; index 0, hence an offset of 12 from the vector's first element
					       (funcall (aref fn (+ 12 alpha))
							omega))))))
	    (\~ (has :titles ("Not" "Excluding"))
		(ambivalent (args :scalar (boolean-op (lambda (omega)
							(cond ((= 0 omega) t)
							      ((= 1 omega) nil)
							      (t (error
								  "Domain error: arguments to ~ must be 1 or 0."))))))
			    (args :any :any (lambda (alpha omega)
					      (let ((to-exclude (if (stringp omega)
								    (array-to-list omega)
								    (array-to-list (make-array
										    (list (array-total-size omega))
										    :displaced-to omega))))
						    (included nil))
						(aops:each (lambda (element)
							     ;;(print (list element to-exclude))
							     (if (not (member element to-exclude))
								 (setq included (cons element included))))
							   alpha)
						(make-array (list (length included))
							    :element-type (cond ((stringp alpha)
										 'character)
										(t t))
							    :initial-contents (reverse included))))))
		(tests (is "~1 0 1" #(0 1 0))
		       (is "1 2 3 4 5 6 7~3 5" #(1 2 4 6 7))
		       (is "'MACARONI'~'ALFREDO'" "MCNI")))
     	    (< (has :title "Less Than")
	       (dyadic (args :scalar (boolean-op <)))
	       (tests (is "3<1 2 3 4 5" #(0 0 0 1 1))))
     	    (≤ (has :title "Less or Equal")
	       (dyadic (args :scalar (boolean-op <=)))
	       (tests (is "3≤1 2 3 4 5" #(0 0 1 1 1))))
     	    (= (has :title "Equal")
	       (dyadic (args :scalar (boolean-op =)))
	       (tests (is "3=1 2 3 4 5" #(0 0 1 0 0))))
     	    (≥ (has :title "Greater or Equal")
	       (dyadic (args :scalar (boolean-op >=)))
	       (tests (is "3≥1 2 3 4 5" #(1 1 1 0 0))))
     	    (> (has :title "Greater")
	       (dyadic (args :scalar (boolean-op >)))
	       (tests (is "3>1 2 3 4 5" #(1 1 0 0 0))))
     	    (≠ (has :title "Not Equal")
	       (dyadic (args :scalar (boolean-op /=)))
	       (tests (is "3≠1 2 3 4 5" #(1 1 0 1 1))))
	    (≡ (has :titles ("Depth" "Match"))
	       (ambivalent (args :any array-depth)
			   (args :any :any (boolean-op equalp))))
	    (≢ (has :title "Not Match")
	       (ambivalent (args :any (lambda (omega) (first (dims omega))))
			   ;; TODO: equalp is not exactly right for this function
			   (args :any :any (boolean-op (lambda (alpha omega) (not (equalp alpha omega)))))))
	    (^ (has :title "And")
	       (dyadic (args :scalar lcm))
	       (tests (is "0 1 0 1 ^ 0 0 1 1" #(0 0 0 1))))
	    (∧ (has :title "And")
	       (dyadic (args :scalar lcm))
	       (tests (is "0 1 0 1 ∧ 0 0 1 1" #(0 0 0 1))))
	    (⍲ (Has :Title "Nand")
	       (dyadic (args :scalar (boolean-op (lambda (alpha omega) (not (and (= alpha 1) (= omega 1)))))))
	       (tests (is "0 1 0 1 ⍲ 0 0 1 1" #(1 1 1 0))))
	    (⍱ (has :title "Nor")
	       (dyadic (args :scalar gcd))
	       (tests (is "0 1 0 1 ⍱ 0 0 1 1" #(1 0 0 0))))
     	    (∨ (has :title "Or")
	       (dyadic (args :scalar (boolean-op (lambda (alpha omega) (not (and (= alpha 0) (= omega 0)))))))
	       (tests (is "0 1 0 1 ∨ 0 0 1 1" #(0 1 1 1))))
	    (⍳ (has :titles ("Index" "Index Of"))
	       (ambivalent (args :one (lambda (omega)
					(make-array (list omega)
						    :initial-contents
						    (mapcar (lambda (i)
							      (+ i (of-environment *vex-idiom* :count-from)))
							    (alexandria:iota omega)))))
			   (args :any :any index-of))
	       (tests (is "⍳5" #(1 2 3 4 5))
		      (is "3⍳1 2 3 4 5" #(2 2 1 2 2))))
     	    (⍴ (has :titles ("Shape" "Reshape"))
	       (ambivalent (args :any dims)
			   (args :any :any (lambda (alpha omega)
					     (reshape-array-fitting omega (array-to-list alpha)))))
	       (tests (is "4 5⍴⍳3" #2A((1 2 3 1 2) (3 1 2 3 1) (2 3 1 2 3) (1 2 3 1 2)))))
	    (∊ (has :titles ("Enlist" "Membership"))
	       (ambivalent (args :any enlist)
			   (args :any :any (lambda (alpha omega)
					     (let ((output (alexandria:copy-array alpha)))
					       (dotimes (index (array-total-size output))
						 (let ((found nil))
						   (aops:each (lambda (input)
								(if (= input (row-major-aref output index))
								    (setq found t)))
							      omega)
						   (setf (row-major-aref output index)
							 (if found 1 0))))
					       output))))
	       (tests (is "∊2 2 2⍴⍳9" #(1 2 3 4 5 6 7 8))
		      (is "2 5 7∊1 2 3 4 5" #(1 1 0))))
	    (↑ (has :titles ("Disclose" "Take"))
	       (ambivalent (args :any (lambda (omega)
					(if (or (not (vectorp omega))
						(not (arrayp (aref omega 0))))
					    omega (aref omega 0))))
			   (args :any :any :axes
				 (lambda (alpha omega &optional axes)
				   (multidim-slice omega (if axes (loop for axis from 0 to (1- (rank omega))
								     collect (if (= axis (1- (aref (first axes) 0)))
										 (aref alpha 0)
										 (nth axis (dims omega))))
							     (array-to-list alpha))
						   :fill-with 0))))
	       (tests (is "↑⊂1 2 3 4" #(1 2 3 4))
		      (is "2 3 4↑4 5 6⍴⍳9" #3A(((1 2 3 4) (7 8 9 1) (4 5 6 7))
					       ((4 5 6 7) (1 2 3 4) (7 8 9 1))))))
	    (↓ (has :titles ("Drop" "Split"))
	       (ambivalent (args :any :axes (lambda (omega &optional axes)
					      ;; NOTE: check this against another implementation
					      (aops:split omega (if axes (aref (first axes) 0)
								    (1- (rank omega))))))
			   (args :any :any :axes
				 (lambda (alpha omega &optional axes)
				   (multidim-slice omega (if axes (loop for axis from 0 to (1- (rank omega))
								     collect (if (= axis (1- (aref (first axes) 0)))
										 (aref alpha 0)
										 0))
							     (array-to-list alpha))
						   :inverse t))))
	       (tests (is "↓3 4⍴⍳9" #(#(1 2 3 4) #(5 6 7 8) #(9 1 2 3)))
		      (is "2 2 2↓4 5 6⍴⍳9" #3A(((3 4 5 6) (9 1 2 3) (6 7 8 9))
					       ((6 7 8 9) (3 4 5 6) (9 1 2 3))))))
	    (⌷ (has :title "Axis")
	       (dyadic (args :any :any (lambda (alpha omega)
					 (apply #'aref (cons omega (array-to-list alpha)))))))
	    (\, (has :titles ("Catenate" "Ravel"))
		(ambivalent (args :any (lambda (omega)
					 (if (vectorp omega)
					     omega (make-array (list (array-total-size omega))
							       :displaced-to omega))))
			    (args :any :any :axes
				  (lambda (alpha omega &optional axes)
				    (if (and (not axes)
					     (vectorp alpha)
					     (vectorp omega))
					(concatenate 'vector alpha omega)
					(aops:stack (if axes (1- (aref (first axes) 0))
							1)
						    alpha omega)))))
		(tests (is ",3 4⍴⍳9" #(1 2 3 4 5 6 7 8 9 1 2 3))
		       (is "(3 6⍴⍳6),3 4⍴⍳9" #2A((1 2 3 4 5 6 1 2 3 4) (1 2 3 4 5 6 5 6 7 8)
						 (1 2 3 4 5 6 9 1 2 3)))))
     	    (⍪ (has :titles ("Catenate First" "Table"))
	       (ambivalent (args :any (lambda (omega) (if (not (second (dims omega)))
							  (make-array (list (length omega) 1)
								      :initial-contents
								      (loop for i from 0 to (1- (length omega))
									 collect (list (aref omega i))))
							  omega)))
			   (args :any :any :axes
				 (lambda (alpha omega &optional axes)
				   (if (and (not axes)
					    (vectorp alpha)
					    (vectorp omega))
				       (if (not (= (length alpha)
						   (length omega)))
					   (error "Vectors must be of same length.")
					   (make-array (list 2 (length alpha))
						       :initial-contents (list (array-to-list alpha)
									       (array-to-list omega))))
				       (aops:stack (if axes (1- (aref (first axes) 0))
						       0)
						   alpha omega)))))
	       (tests (is "⍪3 4⍴⍳9" #2A((1 2 3 4) (5 6 7 8) (9 1 2 3)))
		      (is "(5 4⍴⍳6)⍪3 4⍴⍳9" #2A((1 2 3 4) (5 6 1 2) (3 4 5 6) (1 2 3 4)
						(5 6 1 2) (1 2 3 4) (5 6 7 8) (9 1 2 3)))))
	    (/ (has :title "Compress")
	       (dyadic (args :any :any :axes
			     (lambda (alpha omega &optional axes)
			       (expand-array (array-to-list alpha)
					     omega (if axes (- (rank omega)
							       (- (aref (first axes) 0)
								  (1- (of-environment *vex-idiom* :count-from)))))
					     0 :omit-zeroes t))))
	       (tests (is "1 0 1 0 1/⍳5" #(1 3 5))
		      (is "1 ¯2 3 ¯4 5/⍳5" #(1 0 0 3 3 3 0 0 0 0 5 5 5 5 5))))
	    (⌿ (has :title "Compress First")
	       (dyadic (args :any :any :axes
			     (lambda (alpha omega &optional axes)
			       (expand-array (array-to-list alpha)
					     omega (if axes (- (rank omega)
							       (- (aref (first axes) 0)
								  (1- (of-environment *vex-idiom* :count-from)))))
					     (1- (rank omega))
					     :omit-zeroes t)))))
	    (\\ (has :title "Expand")
		(dyadic (args :any :any :axes
			      (lambda (alpha omega &optional axes)
				(expand-array (array-to-list alpha) ;[1] 1 [2] 0 / [0] 1 [1] 0
					      omega (if axes (- (rank omega)
								(- (aref (first axes) 0)
								   (1- (of-environment *vex-idiom* :count-from)))))
					      0)))))
	    (⍀ (has :title "Expand First")
	       (dyadic (args :any :any :axes
			     (lambda (alpha omega &optional axes)
			       (expand-array (array-to-list alpha)
					     omega (if axes (- (rank omega)
							       (- (aref (first axes) 0)
								  (1- (of-environment *vex-idiom* :count-from)))))
					     (1- (rank omega)))))))
	    (⍷ (has :title "Find")
	       (dyadic (args :any :any find-array)))
	    (⊂ (has :titles ("Enclose" "Partition"))
	       (ambivalent (args :any (lambda (omega)
					(if (loop for dim in (dims omega) always (= 1 dim))
					    omega (make-array (list 1) :initial-element omega))))
			   (args :any :any (lambda (alpha omega)
					     (if (/= (length alpha) (length omega))
						 (error "Length mismatch.")
						 (let ((output nil)
						       (accumulator nil)
						       (partition-index 0))
						   (dotimes (index (length alpha))
						     (if (and (< 0 index)
							      (< partition-index (aref alpha index)))
							 (progn (setq output
								      (cons (make-array (list (length accumulator))
											:initial-contents
											(reverse accumulator))
									    output))
								(setq accumulator nil)))
						     (setq partition-index (aref alpha index))
						     (if (< 0 (aref alpha index))
							 (setq accumulator (cons (aref omega index)
										 accumulator))))
						   (if accumulator (setq output
									 (cons (make-array
										(list (length accumulator))
										:initial-contents
										(reverse accumulator))
									       output)))
						   (make-array (list (length output))
							       :initial-contents (reverse output)))))))
	       (tests (is "⊂3 4⍴⍳7" #(#2A((1 2 3 4) (5 6 7 1) (2 3 4 5))))
		      (is "1 1 2 2 2 3 3 3 3⊂⍳9" #(#(1 2) #(3 4 5) #(6 7 8 9)))))
	    (⊃ (has :titles ("Mix" "Pick"))
	       (ambivalent (args :any (lambda (omega)
					;; currently works for vectors only
					(let ((output (make-array
						       (list (length omega)
							     (apply #'max (array-to-list (aops:each #'length
												    omega)))))))
					  (dotimes (index (length omega))
					    (dotimes (sub-index (length (aref omega index)))
					      (setf (aref output index sub-index)
						    (aref (aref omega index) sub-index))))
					  output)))
			   (args :one :any (lambda (alpha omega)
					     (apply #'aref (cons omega (array-to-list (aref alpha 0))))))))
	    (∪ (has :titles ("Union" "Unique"))
	       (ambivalent (args :any (lambda (omega)
					(if (not (vectorp omega))
					    (error "Argument must be a vector.")
					    (let ((uniques nil))
					      (dotimes (index (length omega))
						(if (not (find (aref omega index)
							       uniques))
						    (setq uniques (cons (aref omega index)
									uniques))))
					      (make-array (list (length uniques))
							  :initial-contents (reverse uniques))))))
			   (args :any :any (lambda (alpha omega)
					     (if (or (not (vectorp alpha))
						     (not (vectorp omega)))
						 (error "Arguments must be vectors.")
						 (let ((uniques nil))
						   (dotimes (index (length omega))
						     (if (not (find (aref omega index)
								    alpha))
							 (setq uniques (cons (aref omega index)
									     uniques))))
						   (concatenate 'vector alpha
								(make-array (list (length uniques))
									    :initial-contents
									    (reverse uniques)))))))))
	    (∩ (has :title "Intersection")
	       (dyadic (args :any :any (lambda (alpha omega)
					 (if (or (not (vectorp alpha))
						 (not (vectorp omega)))
					     (error "Arguments must be vectors.")
					     (let ((matches nil))
					       (dotimes (index (length alpha))
						 (if (find (aref alpha index)
							   omega)
						     (setq matches (cons (aref alpha index)
									 matches))))
					       (make-array (list (length matches))
							   :initial-contents (reverse matches))))))))
	    (⌽ (has :titles ("Reverse" "Rotate"))
	       (ambivalent (args :any :axes (lambda (omega &optional axes)
					      (if (vectorp omega)
						  (let ((new-array (copy-array omega)))
						    (funcall (make-rotator)
							     new-array)
						    new-array)
						  (if (arrayp omega)
						      (apply-marginal (make-rotator)
								      omega (if axes (1- (aref (first axes) 0)))
								      (1- (rank omega)))))))
			   (args :one :any :axes
				 (lambda (alpha omega &optional axes)
				   (if (vectorp omega)
				       (let ((new-array (copy-array omega)))
					 (funcall (make-rotator alpha)
						  new-array)
					 new-array)
				       (if (arrayp omega)
					   (apply-marginal (make-rotator alpha)
							   omega (if axes (1- (aref (first axes) 0)))
							   (1- (rank omega))))))))
	       (tests (is "⌽1 2 3 4 5" #(5 4 3 2 1))
		      (is "⌽3 4⍴⍳9" #2A((4 3 2 1) (8 7 6 5) (3 2 1 9)))
		      (is "2⌽3 4⍴⍳9" #2A((3 4 1 2) (7 8 5 6) (2 3 9 1)))))
     	    (⊖ (has :titles ("Reverse First" "Rotate First"))
	       (ambivalent (args :any :axes (lambda (omega &optional axes)
					      (if (vectorp omega)
						  (let ((new-array (copy-array omega)))
						    (funcall (make-rotator)
							     new-array)
						    new-array)
						  (if (arrayp omega)
						      (apply-marginal (make-rotator)
								      omega (if axes (1- (aref (first axes) 0)))
								      0)))))
			   (args :one :any :axes
				 (lambda (alpha omega &optional axes)
				   (if (vectorp omega)
				       (let ((new-array (copy-array omega)))
					 (funcall (make-rotator alpha)
						  new-array)
					 new-array)
				       (if (arrayp omega)
					   (apply-marginal (make-rotator alpha)
							   omega (if axes (1- (aref (first axes) 0)))
							   0))))))
	       (tests (is "⊖1 2 3 4 5" #(5 4 3 2 1))
		      (is "⊖3 4⍴⍳9" #2A((9 1 2 3) (5 6 7 8) (1 2 3 4)))
		      (is "1⊖3 4⍴⍳9" #2A((5 6 7 8) (9 1 2 3) (1 2 3 4)))))
	    (⍉ (has :titles ("Reverse Axes" "Transpose"))
	       (ambivalent (args :any (lambda (omega)
					(aops:permute (reverse (alexandria:iota (rank omega)))
						      omega)))
			   (args :any :any (lambda (alpha omega)
					     (aops:permute (mapcar (lambda (i)
								     (- i (of-environment *vex-idiom*
											  :count-from)))
								   (array-to-list alpha))
							   omega)))))
            ;; TODO: dyadic functions of ⍋⍒ only support vectors as a right argument
	    (⍋ (has :titles ("Grade Up" "Grade Up By"))
	       (ambivalent (args :any (lambda (omega) (grade omega (alpha-compare #'<=))))
			   (args :any :any (lambda (alpha omega) (grade (index-of alpha omega)
									(alpha-compare #'<))))))
	    (⍒ (has :titles ("Grade Down" "Grade Down By"))
	       (ambivalent (args :any (lambda (omega) (grade omega (alpha-compare #'>=))))
			   (args :any :any (lambda (alpha omega) (grade (index-of alpha omega)
									(alpha-compare #'>))))))
	    ;; TODO: inversion does not yet work for non-square matrices
	    (⌹ (has :titles ("Matrix Inverse" "Matrix Divide"))
	       (ambivalent (args :any (lambda (omega)
					(if (and (= 1 (rank omega))
						 (= 1 (length omega)))
					    (/ (aref omega 0))
					    (invert-matrix omega))))
			   ;; TODO: problems apparent with matrix divide
			   (args :any :any (lambda (alpha omega) (array-inner-product (invert-matrix omega)
										      alpha #'* #'+))))
	       (tests (is "⌹2 2⍴4 9 8 2" #2A((-1/32 9/64) (1/8 -1/16)))))
	    (⊤ (has :title "Encode")
	       (dyadic (args :any :any (lambda (alpha omega)
					 (flet ((rebase (bases number)
						  (let ((operand number)
							(last-base 1)
							(base 1)
							(component 1)
							(element nil))
						    (loop for index from (1- (length bases)) downto 0
						       do (setq last-base base
								base (* base (aref bases index))
								component (if (= 0 base)
									      operand
									      (* base
										 (nth-value 1 (floor (/ operand
													base)))))
								operand (- operand component)
								element (/ component last-base))
						       collect element))))
					   (if (= 1 (length omega))
					       (let ((result (rebase alpha (aref omega 0))))
						 (make-array (list (length result))
							     :initial-contents (reverse result)))
					       (aops:permute (list 1 0)
							     (make-array (list (length omega) (length alpha))
									 :initial-contents
									 (mapcar (lambda (item)
										   (reverse (rebase alpha item)))
										 (array-to-list omega))))))))))
	    (⊥ (has :title "Decode")
	       (dyadic (args :any :any (lambda (alpha omega)
					 (flet ((rebase (bases numerators)
						  (let ((result 0)
							(base 1))
						    (loop for index from (1- (length numerators)) downto 0
						       do (incf result (* base (aref numerators index)))
							 (setf base (* base (aref bases index))))
						    result)))
					   (let ((bases (if (= 1 (length alpha))
							    (make-array (list (first (dims omega)))
									:initial-element (aref alpha 0))
							    (if (not (= (length alpha)
									(let ((d-o (dims omega)))
									  (if (= 1 (length d-o))
									      (first d-o)
									      (second d-o)))))
								(error "Base/element length mismatch.")
								alpha))))
					     (if (= 1 (rank omega))
						 (rebase bases omega)
						 (aops:margin (lambda (sub-array) (rebase bases sub-array))
							      omega 0))))))))
	    (⍎ (has :title "Evaluate")
	       (monadic (args :any (lambda (omega) (eval (vex-program *vex-idiom* nil omega))))))
	    (∘ (has :title "Find Outer Product, Not Inner")
	       (symbolic :outer-product-designator))
	       ))

(defun process-reverse (function input &optional output)
  (if input
      (process-reverse function (rest input)
		       (cons (funcall function (first input))
			     output))
      output))

(defun =vex-operation (idiom meta at-start?)
  "Parse an operation belonging to a Vex expression, returning the operation string and tokens extracted along with the remainder of the expression string."
  (labels ((?blank-character ()
	     (?satisfies (lambda (c) (member c (list #\  #\tab)))))
	   (?token-character ()
	     (%or (?satisfies 'alphanumericp)
		  ;; the ¯ character must be expressed as #\macron to be correctly processed
		  ;; the ̄ (combining_macron) character can be denoted normally, however
		  (?satisfies (lambda (c) (member c (list #\macron #\̄ #\. #\⍺ #\⍵ #\⍬))))))
	   (=string (&rest delimiters)
	     (let ((lastc nil)
		   (delimiter nil))
	       (=destructure (_ content)
		   (=list (?satisfies (lambda (c) (if (member c delimiters)
						      (setq delimiter c))))
			  ;; note: nested quotes must be checked backwards; to determine whether a delimiter
			  ;; indicates the end of the quote, look at previous character to see whether it is a
			  ;; delimiter, then check whether the current character is an escape character #\\
			  (=subseq (%any (?satisfies (lambda (c) (if (or (not lastc)
									 (not (char= lastc delimiter))
									 (char= c #\\))
								     (setq lastc c)))))))
		 (format nil "~a~a" delimiter content))))
	   (=vex-opglyphs ()
	     (let ((ops nil))
	       (flet ((glyph-finder (glyph)
			(cond ((and (not (getf ops :op))
				    (gethash glyph (idiom-operators idiom)))
			       (if (and (not ops)
					(not (getf ops :fn))
					(member glyph (getf (idiom-opindex idiom) :right)))
				   (setf (getf ops :op) glyph)
				   (if (and (getf ops :fn)
					    (member glyph (getf (idiom-opindex idiom) :center)))
				       (setf (getf ops :op) glyph))))
			      ((gethash glyph (idiom-functions idiom))
			       (if (not (getf ops :fn))
				   (setf (getf ops :fn) glyph)
				   (if (and (getf ops :op)
					    (not (getf ops :afn)))
				       (setf (getf ops :afn) glyph))))
			      (t nil))))
		 (=destructure (_ glyph-group)
		     (=list (%any (?blank-character))
			    (=subseq (%any (?satisfies #'glyph-finder))))
		   (declare (ignore glyph-group))
		   ;; if only an operator was found, check whether the glyph is a member of the
		   ;; overloaded lexicon. If so, it will be reassigned as a function glyph, if not an
		   ;; error will occur
		   (if (and (getf ops :op)
			    (not (getf ops :fn)))
		       (if (member (getf ops :op)
				   (idiom-overloaded-lexicon idiom))
			   (setf (getf ops :fn) (getf ops :op)
				 (getf ops :op) nil)))
		   ops))))
	   (=vex-tokens (&optional first-token?) ;; recursive parser for tokens and closures
	     (=destructure (_ axis _ token _ last)
		 (=list (%any (?blank-character))
			(%maybe (=vex-closure "[]" #'handle-axes))
			(%any (?blank-character))
			(if (and first-token? at-start?)
			    ;; only process a function as a value if it's the first token in the expression
			    (%or (=vex-closure "{}" #'handle-function-as-data)
				 (=subseq (%some (?token-character)))
				 (=string #\' #\")
				 (=vex-closure "()"))
			    (%or (=subseq (%some (?token-character)))
				 (=string #\' #\") (=vex-closure "()")))
			(%any (?blank-character))
			(=subseq (%any (?satisfies 'characterp))))
	       (let ((token (if (not axis)
				token (list :axis axis token)))
		     (next (parse last (=vex-tokens))))
		 (if (or (not (stringp token))
			 (not (member (format-value (reverse token))
				      (gethash :functions meta))))
		     (if next (list (cons token (first next))
				    (second next))
			 (list (list token) last))))))
	   (=vex-closure (boundary-chars &optional transform-by)
	     (let ((balance 1))
	       (=destructure (_ enclosed _)
		   (=list (?eq (aref boundary-chars 1))
			  (=transform (=subseq (%some (?satisfies (lambda (char)
								    (if (char= char (aref boundary-chars 1))
									(incf balance 1))
								    (if (char= char (aref boundary-chars 0))
									(incf balance -1))
								    (< 0 balance)))))
				      (if transform-by transform-by
					  (lambda (string-content)
					    (vex-expression idiom meta string-content))))
			  (?eq (aref boundary-chars 0)))
		 enclosed)))
	   (=vex-axes () ;; handle axes, separated by semicolons
	     (=destructure (element _ next last)
		 (=list (=subseq (%some (?satisfies (lambda (c) (not (char= c #\;))))))
			(?eq #\;)
			(%maybe '=vex-axes-parser)
			(=subseq (%any (?satisfies (lambda (c) (not (char= c #\;)))))))
	       (if next (cons element next)
		   (list element last))))
	   (handle-axes (input-string)
	     (let ((axes (parse input-string (=vex-axes))))
	       ;; reverse the order of axes, since we're parsing backwards
	       (process-reverse (lambda (string-content) (vex-expression idiom meta string-content))
				(if axes axes (list input-string)))))
	   (handle-function (input-string)
	     (let ((formatted-function (format-function (vex-expression idiom meta input-string))))
	       (lambda (meta axes omega &optional alpha)
		 (declare (ignorable meta axes))
		 `(funcall ,formatted-function
			   ,@(if alpha (list (macroexpand alpha)))
			   ,(macroexpand omega)))))
	   (handle-function-as-data (input-string)
	     (format-function (vex-expression idiom meta input-string))))
    
    (setf (fdefinition '=vex-tokens-parser) (=vex-tokens)
	  (fdefinition '=vex-axes-parser) (=vex-axes))
    
    (=destructure (_ hd tl last)
	(if at-start? ;; handle the initial value in the expression at the start
	    (=list (%any (?blank-character))
		   (%maybe (=vex-tokens t))
		   (=subseq (%any (?satisfies 'characterp)))
		   (=subseq (%any (?satisfies 'characterp))))
	    ;; then handle each operation (function and sometimes operator) and the following tokens
	    (=list (%any (?blank-character))
		   (=list (%maybe (=vex-closure "[]" #'handle-axes))
		   	  (%or (=vex-closure "{}" #'handle-function)
			       (=subseq (%some (?token-character)))
			       (=vex-opglyphs)))
		   (%maybe (=vex-tokens))
		   (=subseq (%any (?satisfies 'characterp)))))
      (if (and (not at-start?)
      	       (stringp (second hd)))
      	  (let ((function-string (second hd)))
	    (setq hd (list (first hd)
			   (function (lambda (meta axes omega &optional alpha)
			     (declare (ignorable meta axes))
			     (if alpha
				 `(aref (apply-scalar-function ,(format-value (reverse function-string))
							       ,(macroexpand alpha)
							       ,(macroexpand omega))
					0)
				 `(aref (aops:each ,(format-value (reverse function-string))
						   ,(macroexpand omega))
					0))))))))
      ;; if the head of the operation is a string (thus a symbol-referenced function),
      ;; format it and compose the operation spec accordingly
      (if at-start? (setq tl hd hd nil))
      (list hd (if tl
		   (list (process-reverse (lambda (value) (cond ((stringp value)
								 (format-value (reverse value)))
								((and (listp value)
								      (eq :axis (first value)))
								 `(apply #'aref
									 (cons ,(if (stringp (third value))
										    (format-value
										     (reverse (third value)))
										    (third value))
									       (mapcar (lambda (i) (1- (aref i 0)))
										       (list ,@(second value))))))
								(t value)))
					  (first tl))
			 (second tl))
		   (list nil last))))))

(defun vex-expression (idiom meta string &optional precedent)
  "Convert an expression into Lisp code, tranforming the text through the parser and invoking the corresponding spec-defined functions accordingly."
  (if (= 0 (length string))
      precedent
      (let* ((next-operation (parse string (=vex-operation idiom meta (not precedent))))
	     (operation (cadar next-operation))
	     (operation-axes (caar next-operation))
	     (value-results (second next-operation))
	     (operator (if (not (or (functionp operation)
				    (eql 'lambda (first operation))))
			   (gethash (getf operation :op)
				    (idiom-operators idiom))))
	     (function (if (or (functionp operation)
			       (eql 'lambda (first operation)))
			   (list operation)
			   (gethash (getf operation :fn)
				    (idiom-functions idiom))))
	     (alpha-function (if (not (or (functionp operation)
					  (eql 'lambda (first operation))))
				 (gethash (getf operation :afn)
					  (idiom-functions idiom)))))
	(vex-expression idiom meta (second value-results)
			(apply (cond (operator operator)
				     (function (first function))
				     (t (lambda (&rest items) (third items))))
			       (append (list meta operation-axes)
				       (if operator
					   (list (cons function (if alpha-function (list alpha-function)))))
				       (if (first value-results)
					   (list (format-array (first value-results))))
				       (if precedent (list precedent))))))))

(defun vex-program (idiom options &optional string meta)
  (let ((meta (if meta meta (make-hash-table :test #'eq))))
    (labels ((assign-from (source dest)
	       (if source
		   (progn (setf (getf dest (first source))
				(second source))
			  (assign-from (cddr source)
				       dest))
		   dest)))
      (setf (gethash :functions meta)
	    nil)
      (if (getf options :env)
	  (setf (idiom-environment idiom)
		(assign-from (getf options :env)
			     (idiom-environment idiom))))
      (if string
	  `(progn
	     ,@(loop for exp in (cl-ppcre:split "[◊\\r\\n]\\s{0,}" ;; whitespace after diamonds is removed
						(regex-replace-all (concatenate 'string "^\\s{0,}⍝(.*)[\\r\\n]"
										"|(?<=[\\r\\n])\\s{0,}⍝(.*)[\\r\\n]"
										"|(?<=[^\\r\\n])\\s{0,}⍝(.*)(?=[\\r\\n])")
								   ;; remove comments
								   string ""))
		  collect (vex-expression idiom meta (reverse exp))))))))
