;;;; apex.lisp

(in-package #:apex)
 
(defun is-singleton (value)
  "Determine whether an array is a singleton, i.e. possesses just one member."
  (or (and (atom value)
	   (not (arrayp value)))
      ;; non-array atoms are considered singleton values
      (let ((adims (dims value)))
	(and (= 1 (first adims))
	     (= 1 (length adims))))))

(defun apply-scalar-monadic (function omega)
  "Apply a scalar function across a single arguments, iterating over multidimensional and nested arrays."
  (labels ((apply-fn (arg) (if (arrayp arg)
			       (aops:each #'apply-fn arg)
			       (funcall function arg))))
    (aops:each #'apply-fn omega)))

(defun apply-scalar-dyadic (function alpha omega)
  "Apply a scalar function across objects as appropriate in APL. Handles scalars as well as nested and multidimensional arrays."
  (let* ((alpha-scalar? (not (arrayp alpha)))
	 (omega-scalar? (not (arrayp omega)))
	 (alpha-unitary? (and (not alpha-scalar?)
			      (vectorp alpha)
			      (= 1 (length alpha))))
	 (omega-unitary? (and (not omega-scalar?)
			      (vectorp omega)
			      (= 1 (length omega)))))
    (cond ((and alpha-scalar? omega-scalar?)
	   (funcall function alpha omega))
	  ((and alpha-unitary? omega-unitary?)
	   (aops:each (lambda (alpha omega) (apply-scalar-dyadic function alpha omega))
		      alpha omega))
	  ((and (not alpha-unitary?)
		(not omega-unitary?)
		(not alpha-scalar?)
		(not omega-scalar?))
	   (if (loop for dimension in (funcall (lambda (a o) (mapcar #'= a o))
					       (dims alpha)
					       (dims omega))
		  always dimension)
	       (aops:each (lambda (alpha omega) (apply-scalar-dyadic function alpha omega))
			  alpha omega)
	       (error "Array size mismatch.")))
	  (t (labels ((scan-over (element)
			(if (arrayp element)
			    (aops:each #'scan-over element)
			    (apply (lambda (left right) (apply-scalar-dyadic function left right))
				   (cond (alpha-scalar? (list alpha element))
					 (alpha-unitary? (list (aref alpha 0)
							       element))
					 (omega-scalar? (list element omega))
					 (omega-unitary? (list element (aref omega 0))))))))
	       (aops:each #'scan-over (if (or alpha-scalar? alpha-unitary?)
					  omega alpha)))))))

(defmacro mediate-operation (operation)
  "Process the spec for a function or operator, building a function to process its arguments and generate code to run the operation."
  (flet ((mediate-arguments (operation arg-specs a-sym &optional o-sym)
	   ;; moderate arguments to a Vex function at compile time
	   (let* ((alpha-sym o-sym)
		  (omega-sym a-sym)
		  (fn (if (and (listp operation)
			       (macro-function (first operation))
			       (not (eql 'lambda (first operation))))
			  (macroexpand (append operation (if (second arg-specs)
							     (list omega-sym alpha-sym)
							     (list omega-sym))))
			  `(function ,operation))))
	     (if (eq :scalar (first arg-specs))
		 ;; for a scalar function, return both monadic and dyadic variants if applicable
		 (if (eq :dyadic (second arg-specs))
		     ``(funcall #'apply-scalar-dyadic ,,fn ,(macroexpand ,alpha-sym)
				,(macroexpand ,omega-sym))
		     ``(funcall #'apply-scalar-monadic ,,fn ,(macroexpand ,omega-sym)))
		 ;; assign the alpha, omega and axis argument specs
		 (let ((alpha (if (and (second arg-specs)
				       (not (eq :axes (second arg-specs))))
				  (first arg-specs)))
		       (omega (if (or (not (second arg-specs))
				      (eq :axes (second arg-specs)))
				  (first arg-specs)
				  (second arg-specs)))
		       (axes (if (eq :axes (second arg-specs))
				 (second arg-specs)
				 (third arg-specs))))
		   ``(if (and ,,@(cond ((eq :one omega)
					`(`(is-singleton ,(macroexpand ,omega-sym))))
				       ((eq :sym omega)
					`(`(symbolp (quote ,(if (listp (macroexpand ,omega-sym))
								(second (getf (macroexpand ,omega-sym)
									      :initial-contents))
								(macroexpand ,omega-sym)))))))
			      ,,@(if (and alpha (not (eq :any alpha)))
				     (if (eq :one alpha)
					 `(`(is-singleton ,(macroexpand ,alpha-sym))))))
			 ;; if the arguments are scalar (:one), remove them from their arrays for evaluation
			 (funcall ,,fn
				  ,,@(if alpha (list (cond ((eq :one alpha)
							    ``(aref ,(macroexpand ,alpha-sym) 0))
							   ((eq :axes alpha)
							    (cons 'list (macroexpand axes)))
							   ;; alpha is equal to :axes when
							   ;; axes are used for a monadic function
							   (t `(macroexpand ,alpha-sym)))))
				  ,,(cond ((eq :one omega)
					   ``(if (arrayp ,(macroexpand ,omega-sym))
						 (aref ,(macroexpand ,omega-sym) 0)
						 ,(macroexpand ,omega-sym)))
					  ((eq :sym omega)
					   ``(quote ,(if (listp (macroexpand ,omega-sym))
							 (second (getf (macroexpand ,omega-sym)
								       :initial-contents))
							 (macroexpand ,omega-sym))))
					  (t `(macroexpand ,omega-sym)))
				  ,,@(if axes (list ``(list ,@(macroexpand axes)))))))))))
  (let* ((operation-name (intern (string-upcase (first operation))
				 "KEYWORD"))
	 (alpha-sym (intern "ALPHA"))
	 (omega-sym (intern "OMEGA"))
	 (valencies (rest operation))
	 (mediated (if (or (eq :symmetric-scalar (first valencies))
			   (eq :asymmetric-scalar (first valencies)))
		       (list (mediate-arguments (if (third valencies)
						    (third valencies)
						    (second valencies))
						(list :scalar :dyadic)
						alpha-sym omega-sym)
			     (mediate-arguments (second valencies)
						(list :scalar :monadic)
						omega-sym))
		       (append (if (second valencies)
		       		   (list (mediate-arguments (first (last (second valencies)))
		       					    (butlast (rest (second valencies)))
		       					    alpha-sym omega-sym)))
		       	       (let ((arg-specs (butlast (rest (first valencies)))))
		       		 (list (apply #'mediate-arguments
		       			      (append (list (first (last (first valencies))))
						      (list (append arg-specs
								    (if (and (eq :scalar (first arg-specs))
									     (eq :dyadic operation-name))
									(list :dyadic))))
						      (append (if (eq :dyadic operation-name)
								  (list alpha-sym))
							      (list omega-sym))))))))))
    `(lambda (meta axes omega &optional alpha)
       (declare (ignorable meta axes alpha))
       ,(cond ((eq :monadic operation-name)
	       `(if alpha
		    `(progn (error "Valence error - monadic operation."))
		    ,(first mediated)))
	      ((eq :dyadic operation-name)
	       `(if alpha
		    ,(first mediated)
		    `(error "Valence error - dyadic operation.")))
	      ((eq :ambivalent operation-name)
	       `(if alpha ,@mediated)))))))

(defun numeric-string-p (string)
  "Checks whether the argument is a numeric string."
  (handler-case (progn (parse-apl-number-string string) t)
    (condition () nil)))

(defun parse-apl-number-string (number-string &optional imaginary-component)
  "Parse an APL numeric string into a Lisp value, handling high minus signs and the J-notation for complex numbers."
  (let ((nstring (string-upcase number-string)))
    (if (and (not imaginary-component)
	     (find #\J nstring))
	(let ((halves (cl-ppcre:split "J" nstring)))
	  (if (and (= 2 (length halves))
		   (< 0 (length (first halves)))
		   (< 0 (length (second halves))))
	      (complex (parse-apl-number-string (first halves) t)
		       (parse-apl-number-string (second halves) t))))
	;; either the macron or combining_macron character may be used as the high minus sign
	(parse-number:parse-number (regex-replace-all "[¯̄]" nstring "-")))))

(defun format-value (meta element)
  "Convert a token string into an APL value, paying heed to APL's native ⍺, ⍵ and ⍬ variables."
  (cond ((and (vectorp element)
	      (string= element "⍬"))
	 ;; APL's "zilde" character translates to an empty vector
 	 (make-array (list 0)))
	((and (vectorp element)
	      (or (string= element "⍺")
		  (string= element "⍵")))
	 ;; alpha and omega characters are directly changed to symbols
 	 (intern element))
	((numeric-string-p element)
	 (parse-apl-number-string element))
	((or (and (char= #\" (aref element 0))
		  (char= #\" (aref element (1- (length element)))))
	     (and (char= #\' (aref element 0))
		  (char= #\' (aref element (1- (length element))))))
	 ;; strings are converted to Lisp strings and passed through
	 (subseq element 1 (1- (length element))))
	((stringp element)
	 ;; variable references are converted into generated symbols from the variable table or,
	 ;; if no reference is found in that table, a new reference is created there and a new symbol
	 ;; is generated
	 (if (not (gethash :variables meta))
	     (setf (gethash :variables meta)
		   (make-hash-table :test #'eq)))
	 (let ((variable-found (gethash (intern element "KEYWORD")
					(gethash :variables meta))))
	   (if variable-found
	       variable-found
	       ;; create a new variable if no variable is found matching the string
	       (setf (gethash (intern element "KEYWORD")
			      (gethash :variables meta))
		     (gensym)))))
	(t element)))

(defun format-array (values)
  "Format an APL array, passing through values that are already arrays."
  (if (or (stringp (first values))
	  (symbolp (first values))
	  (and (not (second values))
	       (or (listp (first values))
		   (functionp (first values)))))
      ;; if the first item is a list (i.e. code to generate an array of some kind),
      ;; pass it through with no changes. Also pass through strings, which are already arrays,
      ;; any symbols
      (first values)
      `(make-array (list ,(length values))
		   :initial-contents (list ,@values))))

(defun format-function (idiom-name content)
  "Format an APL function, reversing the order of alpha and omega arguments to reflect the argument order of Lisp as opposed to APL."
  (let ((⍺ (intern "⍺" idiom-name))
	(⍵ (intern "⍵" idiom-name)))
    `(lambda (,⍺ &optional ,⍵)
       ;; kludge to handle reversing the variable order
       ;; the latter variable is always the optional one in Lisp, but in APL
       ;; the ⍺ is the optional argument
       (if ,⍵ (funcall (lambda (,⍺ ,⍵)
			 (declare (ignorable ,⍺))
			 ,content)
		       ,⍵ ,⍺)
	     (funcall (lambda (,⍵) ,content) ,⍺)))))

(defun apl-symbol (item)
  "Handle APL symbols encountered by the parser. Currently, this means disclosing them if they are singletons referenced in arrays."
  (if (and (arrayp item)
	   (is-singleton item))
      (aref item 0)
      item))

(defun assemble-value (idiom meta subprocessor precedent exp &optional output axes)
  "Assemble a value from tokens output by the parser; this may be a space-separated vector or a unitary value (processed as a 1-element vector by APL)."
  (if (or (not exp)
	  (and (symbolp (first exp))
	       (member (first exp)
		       (gethash :functions meta)))
	  (and (listp (first exp))
	       (keywordp (caar exp))
	       (or (not (eq :axes (caar exp)))
		   (listp (second exp)))
	       ;; break on axes if the next element is an operation rather than a value
	       (or (not (eq :fn (caar exp)))
		   (not (functionp (cadar exp)))
		   output precedent)))
      (values (cond ((not output)
		     (if (and (not precedent)
			      (eq :fn (caar exp)))
			 :fun-comp))
		    ((and (= 1 (length output))
			  ;; disclose strings since they're treated as arrays
			  ;; disclose arrays and lists (which specify computed values)
			  ;; disclose single symbols since any value they represent will be vectorized
			  (or (stringp (first output))
			      (symbolp (first output))
			      (listp (first output))
			      (arrayp (first output))))
		     (first output))
		    (t (cons 'vector output)))
	      exp)
      (assemble-value idiom meta subprocessor precedent (rest exp)
		      (cons (cond ((and (listp (first exp))
					(eq :axes (caar exp)))
				   ;; this placeholder keyword is removed in the next iteration
				   :axes-placeholder)
				  ((and (listp (first exp))
					(not (keywordp (caar exp))))
				   ;; if the element is a list and doesn't begin with a keyword,
				   ;; it's a closure and should be handled by the expression processor
				   (cons 'progn (mapcar (lambda (sub-exp)
							  (funcall subprocessor idiom meta sub-exp))
							(first exp))))
				  ((and (listp (first exp))
					(eq :fn (caar exp)))
				   `(lambda (alpha &optional omega)
				      ,(funcall (cadar exp)
						meta nil 'omega 'alpha)))
				  ((symbolp (first exp))
				   (if axes
				       `(apply #'aref (cons (apl-symbol ,(first exp))
							    (mapcar (lambda (vector) (aref vector 0))
								    ,(cons 'list axes))))
				       ;; symbol preprocessing is not applied to ⍺ and ⍵
				       ;; since they represent arguments to a function that already went
				       ;; through processing
				       (if (or (eql '⍺ (first exp))
					       (eql '⍵ (first exp)))
					   (first exp)
					   `(apl-symbol ,(first exp)))))
				  (t (if axes
					 `(apply #'aref (cons ,(first exp)
							      (mapcar (lambda (item) (aref item 0))
								      ,(cons 'list axes))))
					 (first exp))))
			    ;; :axes-placeholder is removed here if axes are being processed this iteration
			    (if axes (rest output)
				output))
		      (if (and (listp (first exp))
			       (eq :axes (caar exp)))
			  (cdar exp)))))

(defun assemble-operation (idiom meta subprocessor precedent exp &key (axes nil) (from-pivot nil))
  "Assemble an APL operation from parsed tokens. The simplest operations consist of a single function, like '+', while operators can be used to combine functions for more complex operations."
  (let ((head (first exp))
	(next (second exp))
	(tail (rest exp)))
    (macrolet ((get-function (symbol)
		 `(let ((function (if (or (characterp ,symbol)
					  (symbolp ,symbol))
				      (of-functions idiom ,symbol)
				      ,symbol)))
		    (if axes (lambda (meta unused omega &optional alpha)
			       (declare (ignore unused))
			       (funcall function meta axes omega alpha))
			function))))
      ;; (print (list 909 head))
      (cond ((symbolp head)
	     (values (lambda (meta axes alpha &optional omega)
		       (declare (ignore meta axes))
		       `(funcall ,head ,alpha ,@(if omega (list omega))))
		     tail))

	    ((eq :axes (first head))
	     ;; if an axes object is found, process the next item in the list with the :axes option
	     ;; filled with the found object
	     (multiple-value-bind (following-axes from-following-axes)
		 (assemble-operation idiom meta subprocessor precedent tail :axes (list (second head)))
	       (values following-axes from-following-axes)))

	    ((and (eq :fn (first head))
		  (or (not tail)
		      (not (listp next))
		      (not (keywordp (first next)))
		      (eq :fn (first next))
		      (and (eq :op (first next))
			   (eq :right (second next)))))
	     ;; finish assembling the operation if the token list is at its end, the next item is not a
	     ;; function or operator, or the next item is another function or right operand
	     (values (get-function (second head))
		     tail))

	    ((and (eq :fn (first head))
		  (eq :op (first next))
		  (eq :center (second next)))
	     ;; if the next glyph is a center operator glyph, perform the first stage of its assembly
	     ;; and then execute the resulting operation on the head glyph, thus completing the assembly
	     (multiple-value-bind (following-op from-following-op)
		 (assemble-operation idiom meta subprocessor precedent tail)
	       (values (funcall following-op meta (cons 'list axes)
				(get-function (second head)))
		       from-following-op)))

	    ((and (eq :op (first head))
		  (or from-pivot (not (eq :center (second head))))
		  ;; note: center operator glyphs cannot be overloaded as function glyphs if they follow
		  ;; another center operator glyph
		  (or (not tail)
		      (not (and (listp next)
				(eq :fn (first next))))))
	     ;; if no function follows a right operator glyph, check whether it's actually an overloaded
	     ;; function glyph and reassign if so
	     (if (of-overloaded? idiom (first (last head)))
		 (values (get-function (first (last head)))
			 tail)
		 (error "Found operator with no accompanying function.")))

	    ((eq :op (first head))
	     ;;(print (list :hh head tail))
	     ;; handle any other operator
	     (multiple-value-bind (following-op from-following-op)
		 (if (listp next)
		     (assemble-operation idiom meta subprocessor precedent tail :from-pivot t)
		     (assemble-value idiom meta subprocessor precedent tail))
	       (values (funcall (of-operators idiom (first (last head)))
				meta (cons 'list axes)
				following-op)
		       from-following-op)))))))

(vex-spec
 apex
 (state :count-from 1
	:atomic-vector
	(concatenate 'string "!\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`"
		     "abcdefghijklmnopqrstuvwxyz{|}~¥€⇄∧∼≬⋆⋸⌸⌺⌼⌾⍁¡⍣⍅⎕⍞⌹⍆⍤⍇⍈⍊⊤λ⍍⍏£⊥⍶⌶⍐⍑χ≢⍖⍗"
		     "⍘⍚⍛⌈⍜⍢∪⍨⍕⍎⍬⍪∣│┤⍟∆∇→╣║╗╝←⌊┐└┴┬├─┼↑↓╔╚╩╦╠═╬≡⍸⍷∵⌷⍂⌻⊢⊣◊┘┌█▄▌▐▀"
		     "⍺⍹⊂⊃⍝⍲⍴⍱⌽⊖○∨⍳⍉∈∩⌿⍀≥≤≠×÷⍙∘⍵⍫⍋⍒¯¨"))
 (utilities :match-blank-character
	    (lambda (char) (member char (list #\  #\Tab)))
	    :match-newline-character
	    (lambda (char) (member char (list #\◊ #\Newline #\Return)))
	    :match-token-character
	    (lambda (char)
	      ;; the ¯ character must be expressed as #\macron to be correctly processed
	      ;; the ̄ (combining_macron) character can be denoted normally, however
	      (or (alphanumericp char)
		  (member char (list #\macron #\̄ #\. #\⍺ #\⍵ #\⍬))))
	    :prep-code-string
	    (lambda (string)
	      ;; remove comments, including comment-only lines
	      (regex-replace-all (concatenate 'string "^\\s{0,}⍝(.*)[\\r\\n]|(?<=[\\r\\n])\\s{0,}⍝(.*)[\\r\\n]"
					      "|(?<=[\\r\\n])\\s{0,}⍝(.*)[\\r\\n]"
					      "|(?<=[^\\r\\n])\\s{0,}⍝(.*)(?=[\\r\\n])")
				 string ""))
	    :format-value #'format-value
	    :format-object #'format-array
	    :format-function #'format-function
	    :mediate-operation-macro 'mediate-operation
	    :assemble-value #'assemble-value
	    :assemble-operation #'assemble-operation
	    :apply-scalar-monadic #'apply-scalar-monadic
	    :apply-scalar-dyadic #'apply-scalar-dyadic)
 (operators (/ (has :title "Reduce")
	       (right (lambda (meta unused omega &optional alpha)
			(declare (ignore alpha unused))
			`(let ((new-array (copy-array ,omega)))
			   (if (= 1 (rank new-array))
			       (vector (reduce (lambda (alpha omega)
						 ,(funcall function meta nil 'omega 'alpha))
					       new-array))
			       (aops:margin (lambda (sub-array) (reduce (lambda (alpha omega)
									  ,(funcall function
										    meta nil 'alpha 'omega))
									sub-array))
					    new-array (if ,axes (1- (aref (first ,axes) 0))
							  (1- (rank new-array))))))))
 	       (tests (is "+/1 2 3 4 5" #(15))
 		      (is "+/3 4⍴⍳12" #(10 26 42))
 		      (is "+/[1]3 4⍴⍳12" #(15 18 21 24))))
  	    (⌿ (has :title "Reduce First")
	       (right (lambda (meta unused omega &optional alpha)
			(declare (ignore alpha unused))
			`(let ((new-array (copy-array ,omega)))
			   (if (= 1 (rank new-array))
			       (vector (reduce (lambda (alpha omega)
						 ,(funcall function meta nil 'omega 'alpha))
					       new-array))
			       (aops:margin (lambda (sub-array) (reduce (lambda (alpha omega)
									  ,(funcall function
										    meta nil 'alpha 'omega))
									sub-array))
					    new-array (if ,axes (1- (aref (first ,axes) 0))
							  0))))))
 	       (tests (is "+⌿3 4⍴⍳12" #(15 18 21 24))
		      (is "+⌿[2]3 4⍴⍳12" #(10 26 42))))
 	    (\\ (has :title "Scan")
		(right (lambda (meta unused omega &optional alpha)
			 (declare (ignore alpha unused))
			 `(if (vectorp ,omega)
			      (funcall (make-back-scanner (lambda (alpha omega)
							    ,(funcall function meta nil 'alpha 'omega)))
				       ,omega)
			      (if (arrayp ,omega)
				  (apply-marginal (make-back-scanner (lambda (alpha omega)
								       ,(funcall function
										 meta nil 'alpha 'omega)))
						  ,omega (if ,axes (1- (aref (first ,axes) 0)))
						  (1- (rank ,omega)))))))
 	    	(tests (is "+\\1 2 3 4 5" #(1 3 6 10 15))
 	    	       (is "+\\3 4⍴⍳12" #2A((1 3 6 10) (5 11 18 26) (9 19 30 42)))
		       (is "+\\[1]3 4⍴⍳12" #2A((1 2 3 4) (6 8 10 12) (15 18 21 24)))))
 	    (⍀ (has :title "Scan First")
	       (right (lambda (meta unused omega &optional alpha)
			(declare (ignore alpha unused))
			`(if (vectorp ,omega)
			     (funcall (make-back-scanner (lambda (alpha omega)
							   ,(funcall function meta nil 'alpha 'omega)))
				      ,omega)
			     (if (arrayp ,omega)
				 (apply-marginal (make-back-scanner (lambda (alpha omega)
								      ,(funcall function
										meta nil 'alpha 'omega)))
						 ,omega (if ,axes (1- (aref (first ,axes) 0)))
						 0)))))
 	       (tests (is "+⍀1 2 3 4 5" #(1 3 6 10 15))
 	    	      (is "+⍀3 4⍴⍳12" #2A((1 2 3 4) (6 8 10 12) (15 18 21 24)))
		      (is "+⍀[2]3 4⍴⍳12" #2A((1 3 6 10) (5 11 18 26) (9 19 30 42)))))
 	    (\. (has :title "Inner/Outer Product")
	    	(center (macro (lambda (meta axes right-function)
				 (declare (ignore meta axes))
				 (if (eq :outer-product-designator right-function)
				     (lambda (meta axes left-function)
				       (declare (ignore meta axes))
				       (lambda (meta unused omega alpha)
					 (declare (ignore unused))
					 `(aops:outer (lambda (alpha omega)
							,(funcall left-function meta nil 'alpha 'omega))
						      ,omega ,alpha)))
				     (lambda (meta axes left-function)
				       (declare (ignore meta axes))
				       (lambda (meta unused omega alpha)
					 (declare (ignore unused))
					 `(if (and (vectorp ,omega)
						   (vectorp ,alpha))
					      ;; TODO: improve logic for the argument?
					      (make-array (list 1)
							  :initial-element
							  (reduce (lambda (alpha omega)
								    ,(funcall right-function
									      meta nil 'alpha 'omega))
								  (aops:each (lambda (alpha omega)
									       ,(funcall left-function
											 meta nil 'alpha 'omega))
									     ,alpha ,omega)))
					      (array-inner-product ,omega ,alpha
					      			   (let ((f1 (lambda (alpha omega)
					      				       ,(funcall left-function
					      						 meta nil 'alpha 'omega))))
					      			     (lambda (arg1 arg2)
					      			       (if (or (arrayp arg1)
					      				       (arrayp arg2))
					      				   (apply-scalar-dyadic f1 arg1 arg2)
					      				   (funcall f1 arg1 arg2))))
					      			   (lambda (alpha omega)
					      			     ,(funcall right-function
					      				       meta nil 'alpha 'omega))))))))))
 	    	(tests (is "2 3 4+.×8 15 21" #(145))
	    	       (is "2 3 4+.×3 3⍴3 1 4 1 5 9 2 6 5" #(17 41 55))
	    	       (is "(3 3⍴3 1 4 1 5 9 2 6 5)+.×2 3 4" #(25 53 42))
 	    	       (is "4 5 6∘.+20 30 40 50" #2A((24 34 44 54) (25 35 45 55) (26 36 46 56)))))
 	    (\¨ (has :title "Each")
		(right (lambda (meta axes omega &optional alpha)
			 (declare (ignore axes))
			 (let ((placeholder nil))
			   (if alpha (setq placeholder omega
					   omega alpha
					   alpha placeholder))
			   `(let ((new-array (copy-array ,omega)))
			      ,(if alpha
				   `(let ((right-arg ,alpha))
				      (make-array (dims right-arg)
						  :initial-contents
						  (loop for index from 0 to (1- (length right-arg))
						     collect (funcall (lambda (alpha omega)
									,(funcall function
										  meta nil 'alpha 'omega))
								      (vector (aref right-arg index))
								      (aref new-array 0)))))
				   `(aops:each (lambda (item) (funcall (lambda (omega)
									 ,(funcall function meta nil 'omega))
								       item))
					       new-array))))))
 	   	(tests (is "⍳¨1 2 3" #(#(1) #(1 2) #(1 2 3)))
		       (is "1 ¯1 ⌽¨⊂1 2 3 4 5" #(#(2 3 4 5 1) #(5 1 2 3 4)))))
 	   (⍨ (has :title "Commute")
	      (right (lambda (meta axes omega &optional alpha)
		       (funcall function meta axes (if alpha alpha omega)
				omega)))
 	      (tests (is "5-⍨10" #(5))))
 	   (∘ (has :title "Compose")
	      (center (macro (lambda (meta axes left-operand)
			       (declare (ignore meta axes))
			       (let ((composed-function nil))
				 (labels ((enclose (meta unused omega &optional alpha)
					    (declare (ignore unused alpha))
					    ;; (print (list :eg composed-function left-operand omega))
					    (cond ((and (not composed-function)
							(not (functionp left-operand)))
						   ;; mode 2: curry function with left argument
						   (setq composed-function
							 `(funcall (lambda (omega alpha)
								     ,(funcall omega meta nil 'omega 'alpha))
								   ,left-operand omega))
						   #'enclose)
						  ((and (not composed-function)
							(not (functionp omega)))
						   ;; mode 3: curry function with right argument
						   `(lambda (omega)
						      (declare (ignorable alpha))
						      (funcall (lambda (omega alpha)
								 ,(funcall left-operand
									   meta nil 'omega 'alpha))
							       omega ,omega)))
						  ((and (not composed-function)
							(functionp left-operand))
						   (setq composed-function
							 `(funcall (lambda (omega)
								     ,(funcall omega meta nil 'omega))
								   (funcall (lambda (omega)
									      ,(funcall left-operand
											meta nil 'omega))
									    omega)))
						   #'enclose)
						  ((functionp omega)
						   (setq composed-function
							 `(funcall (lambda (omega)
								     ,(funcall omega meta nil 'omega))
								   ,composed-function))
						   #'enclose)
						  ((eq :fun-comp omega)
						   `(lambda (omega &optional alpha)
						      (declare (ignorable alpha))
						      ,composed-function))
						  ((or (listp omega)
						       (symbolp omega))
						   ;; a list passed as omega means that a calculated value is
						   ;; on the right side of the composite
						   `(funcall (lambda (omega &optional alpha)
							       (declare (ignorable alpha))
							       ,composed-function)
							     ,omega))
						  (t #'enclose))))
				   #'enclose)))))
	      (tests (is "a←⍴∘⍴ ◊ a 2 3 4⍴⍳9" #(3))
		     (is "⍴∘⍴2 3 4⍴⍳9" #(3))
		     (is "⍴∘⍴∘⍴2 3 4⍴⍳9" #(1))))
	   (⍣ (has :title "Power")
	      (center (macro (lambda (meta axes left-function)
			       (declare (ignore meta axes))
			       (lambda (meta axes right-operand)
				 (declare (ignore axes))
				 (cond ((and (listp right-operand)
					     (integerp (second right-operand)))
					(let ((arg (gensym)))
					  `(lambda (omega &optional alpha)
					     (declare (ignorable alpha))
					     (let ((,arg omega))
					       (loop for index from 0 to ,(1- (second right-operand))
						  do (setq ,arg ,(funcall left-function meta nil arg)))
					       ,arg))))
				       ((listp right-operand)
					(let ((arg (gensym)))
					  `(lambda (omega &optional alpha)
					     (declare (ignorable alpha))
					     (let ((,arg omega))
					       (loop while (not (= 0 (aref (funcall ,right-operand ,arg) 0)))
						  do (setq ,arg ,(funcall left-function meta nil arg)))
					       ,arg)))))))))
	      (tests (is "fn←{2+⍵}⍣3 ◊ fn 5" #(11))
		     (is "fn←{2+⍵}⍣{10>⍵} ◊ fn 2" #(10)))))
 (functions (← (has :title "Assign")
	       (dyadic (macro (lambda (meta axes alpha omega)
				(declare (ignorable axes))
	    			(let ((symbol (if (listp alpha)
						  (second alpha)
						  alpha)))
				  ;;(print (list :om omega))
				  (if (or (eql 'lambda (first omega))
					  (and (listp (second omega))
					       (eql 'lambda (caadr omega))))
				      ;; assign from either a disclosed or enclosed function definition,
				      ;; i.e. a←⍴∘⍴ or a←(⍴∘⍴).
				      (setf (gethash :functions meta)
					    (cons symbol (gethash :functions meta))))
				  `(setq ,symbol ,omega)))))
	       (tests (is "x←55 ◊ 1+3 ◊ x" 55)))
	    (⊣ (has :title "Left")
	       (ambivalent (args :any (lambda (omega)
	    				(declare (ignore omega))
	    				(make-array (list 0))))
	    		   (args :any :any (lambda (alpha omega)
	    				     (declare (ignore omega))
	    				     alpha)))
	       (tests (is "⊣77" #())
		      (is "55⊣77" #(55))))
	    (⊢ (has :title "Right")
	       (ambivalent (args :any (lambda (omega) omega))
	    		   (args :any :any (lambda (alpha omega)
	    				     (declare (ignore alpha))
	    				     omega)))
	       (tests (is "⊢77" #(77))
		      (is "55⊢77" #(77))))
	    (+ (has :titles ("Identity or Negate Imaginary" "Add"))
	       (ambivalent :asymmetric-scalar (lambda (omega) (if (complexp omega)
								  (complex (realpart omega)
									   (- (imagpart omega)))
								  omega))
			   +)
	       (tests (is "+5" #(5))
		      (is "+5J2" #(#C(5 -2)))
		      (is "1+1" #(2))
		      (is "1+1 2 3" #(2 3 4))))
    	    (- (has :titles ("Negate" "Subtract"))
	       (ambivalent :symmetric-scalar -)
	       (tests (is "2-1" #(1))
		      (is "7-2 3 4" #(5 4 3))))
     	    (× (has :titles ("Sign" "Multiply"))
	       (ambivalent :asymmetric-scalar signum *)
	       (tests (is "×20 5 0 ¯5 5 ¯9" #(1 1 0 -1 1 -1))
		      (is "2×3" #(6))
		      (is "4 5×8 9" #(32 45))))
     	    (÷ (has :titles ("Reciprocal" "Divide"))
	       (ambivalent :symmetric-scalar /)
	       (tests (is "6÷2" #(3))
		      (is "12÷6 3 2" #(2 4 6))
		      (is "÷2 4 8" #(1/2 1/4 1/8))))
     	    (⋆ (has :titles ("Exponential" "Power"))
	       (ambivalent :asymmetric-scalar exp expt)
	       (tests (is "⌊1000×⋆2" #(7389))
		      (is "2⋆4" #(16))
		      (is "⌊16⋆÷2" #(4))))
     	    (* (has :titles ("Exponential" "Power"))
	       (ambivalent :asymmetric-scalar exp expt))
     	    (⍟ (has :titles ("Natural Logarithm" "Logarithm"))
	       (ambivalent :asymmetric-scalar log (lambda (alpha omega) (log omega alpha)))
	       (tests (is "⌊1000×⍟5" #(1609))
		      (is "⌊2⍟8" #(3))))
     	    (\| (has :titles ("Magnitude" "Residue"))
	    	(ambivalent :asymmetric-scalar abs (lambda (alpha omega) (mod omega alpha)))
		(tests (is "|55" #(55))
		       (is "|¯33" #(33))
		       (is "8|39" #(7))))
     	    (! (has :titles ("Factorial" "Binomial"))
	       (ambivalent :asymmetric-scalar sprfact binomial)
	       (tests (is "!5" #(120))
		      (is "5!12" #(792))))
     	    (⌈ (has :titles ("Ceiling" "Maximum"))
	       (ambivalent :asymmetric-scalar ceiling max)
	       (tests (is "⌈1.0001" #(2))
		      (is "⌈1.9998" #(2))
		      (is "3⌈0 1 2 3 4 5" #(3 3 3 3 4 5))))
     	    (⌊ (has :titles ("Floor" "Minimum"))
	       (ambivalent :asymmetric-scalar floor min)
	       (tests (is "⌊1.0001" #(1))
		      (is "⌊1.9998" #(1))
		      (is "3⌊0 1 2 3 4 5" #(0 1 2 3 3 3))))
	    (? (has :titles ("Random" "Deal"))
	       (ambivalent (args :scalar (lambda (omega)
	    				   (+ (random omega)
	    				      (of-state *apex-idiom* :count-from))))
	    		   (args :one :one (lambda (alpha omega)
	    				     (make-array (list alpha)
	    						 :initial-contents
	    						 (loop for i from 0 to (1- alpha)
	    						    collect (+ (random omega)
	    							       (of-state *apex-idiom* :count-from))))))))
     	    (○ (has :titles ("Pi Times" "Circular"))
	       (ambivalent (args :scalar (lambda (omega) (* pi omega)))
	    		   (args :one :any (lambda (alpha omega)
	    				     (let ((fn (vector (lambda (input) (exp (* input #C(0 1))))
	    						       (lambda (input) (* input #C(0 1)))
	    						       (lambda (input) (if (complexp input)
	    									   (complex (realpart input)
	    										    (- (imagpart input)))
	    									   input))
	    						       (lambda (input) input)
	    						       (lambda (input) (expt (- -1 (* 2 input))
	    									     1/2))
	    						       #'atanh #'acosh #'asinh
	    						       (lambda (input) (* (expt (/ (1+ input) (1- input))
	    										1/2)
	    									  (1+ input)))
	    						       #'atan #'acos #'asin
	    						       (lambda (input) (expt (- 1 (* 2 input))
	    									     1/2))
	    						       #'sin #'cos #'tan
	    						       (lambda (input) (expt (1+ (* 2 input))
	    									     1/2))
	    						       #'sinh #'cosh #'tanh
	    						       (lambda (input) (expt (- -1 (* 2 input))
	    									     1/2))
	    						       #'realpart #'abs #'imagpart #'phase)))
	    				       ;; the twelfth element of the vector corresponds to
	    				       ;; index 0, hence an offset of 12 from the vector's first element
	    				       (apply-scalar-monadic (aref fn (+ 12 alpha))
								     omega)))))
	       (tests (is "⌊100000×○1" #(314159))
		      (is "(⌊1000×1÷2⋆÷2)=⌊1000×1○○÷4" #(1))))
	    (\~ (has :titles ("Not" "Excluding"))
	    	(ambivalent (args :scalar
				  (boolean-op (lambda (omega)
						(cond ((= 0 omega) t)
						      ((= 1 omega) nil)
						      (t (error
							  "Domain error: arguments to ~ must be 1 or 0."))))))
	    		    (args :any :any (lambda (alpha omega)
	    				      (let ((to-exclude (if (stringp omega)
	    							    (array-to-list omega)
	    							    (array-to-list (make-array
	    									    (list (array-total-size omega))
	    									    :displaced-to omega))))
	    					    (included nil))
	    					(aops:each (lambda (element)
	    						     ;;(print (list element to-exclude))
	    						     (if (not (member element to-exclude))
	    							 (setq included (cons element included))))
	    						   alpha)
	    					(make-array (list (length included))
	    						    :element-type (element-type alpha)
	    						    :initial-contents (reverse included))))))
	    	(tests (is "~1 0 1" #(0 1 0))
	    	       (is "1 2 3 4 5 6 7~3 5" #(1 2 4 6 7))
	    	       (is "'MACARONI'~'ALFREDO'" "MCNI")))
     	    (< (has :title "Less Than")
	       (dyadic (args :scalar (boolean-op <)))
	       (tests (is "3<1 2 3 4 5" #(0 0 0 1 1))))
     	    (≤ (has :title "Less or Equal")
	       (dyadic (args :scalar (boolean-op <=)))
	       (tests (is "3≤1 2 3 4 5" #(0 0 1 1 1))))
     	    (= (has :title "Equal")
	       (dyadic (args :scalar (boolean-op (lambda (alpha omega)
	    					   (cond ((and (numberp alpha)
	    						       (numberp omega))
	    						  (= alpha omega))
	    						 ((and (characterp alpha)
	    						       (characterp omega))
	    						  (char= alpha omega)))))))
	       (tests (is "3=1 2 3 4 5" #(0 0 1 0 0))))
     	    (≥ (has :title "Greater or Equal")
	       (dyadic (args :scalar (boolean-op >=)))
	       (tests (is "3≥1 2 3 4 5" #(1 1 1 0 0))))
     	    (> (has :title "Greater")
	       (dyadic (args :scalar (boolean-op >)))
	       (tests (is "3>1 2 3 4 5" #(1 1 0 0 0))))
     	    (≠ (has :title "Not Equal")
	       (dyadic (args :scalar (boolean-op /=)))
	       (tests (is "3≠1 2 3 4 5" #(1 1 0 1 1))))
	    (≡ (has :titles ("Depth" "Match"))
	       (ambivalent (args :any array-depth)
	    		   (args :any :any (boolean-op equalp))))
	    (≢ (has :title "Not Match")
	       (ambivalent (args :any (lambda (omega) (first (dims omega))))
	    		   ;; TODO: equalp is not exactly right for this function
	    		   (args :any :any (boolean-op (lambda (alpha omega) (not (equalp alpha omega)))))))
	    (^ (has :title "And")
	       (dyadic (args :scalar lcm))
	       (tests (is "0 1 0 1 ^ 0 0 1 1" #(0 0 0 1))))
	    (∧ (has :title "And")
	       (dyadic (args :scalar lcm))
	       (tests (is "0 1 0 1 ∧ 0 0 1 1" #(0 0 0 1))))
	    (⍲ (has :title "Nand")
	       (dyadic (args :scalar (boolean-op (lambda (alpha omega) (not (= alpha omega 1))))))
	       (tests (is "0 1 0 1 ⍲ 0 0 1 1" #(1 1 1 0))))
     	    (∨ (has :title "Or")
	       (dyadic (args :scalar gcd))
	       (tests (is "0 1 0 1 ∨ 0 0 1 1" #(0 1 1 1))))
	    (⍱ (has :title "Nor")
	       (dyadic (args :scalar (boolean-op (lambda (alpha omega) (= alpha omega 0)))))
	       (tests (is "0 1 0 1 ⍱ 0 0 1 1" #(1 0 0 0))))
	    (⍳ (has :titles ("Index" "Index Of"))
	       (ambivalent (args :one (lambda (omega)
	    				(make-array (list omega)
	    					    :initial-contents
	    					    (mapcar (lambda (i) (+ i (of-state *apex-idiom* :count-from)))
	    						    (alexandria:iota omega)))))
	    		   (args :any :any index-of))
	       (tests (is "⍳5" #(1 2 3 4 5))
	    	      (is "3⍳1 2 3 4 5" #(2 2 1 2 2))))
     	    (⍴ (has :titles ("Shape" "Reshape"))
	       (ambivalent (args :any (lambda (omega)
					(let ((omega-dims (dims omega)))
					  (make-array (list (length omega-dims))
						      :initial-contents omega-dims))))
	    		   (args :any :any (lambda (alpha omega)
	    				     (reshape-array-fitting omega (array-to-list alpha)))))
	       (tests (is "⍴1 2 3" #(3))
		      (is "⍴3 5⍴⍳8" #(3 5))
		      (is "4 5⍴⍳3" #2A((1 2 3 1 2) (3 1 2 3 1) (2 3 1 2 3) (1 2 3 1 2)))))
	    (∊ (has :titles ("Enlist" "Membership"))
	       (ambivalent (args :any enlist)
	    		   (args :any :any (lambda (alpha omega)
	    				     (let ((output (make-array (dims alpha))))
	    				       (dotimes (index (array-total-size output))
	    					 (let ((found nil))
	    					   (aops:each (lambda (input)
	    							(cond ((and (numberp input)
	    								    (numberp (row-major-aref alpha index))
	    								    (= input (row-major-aref alpha index)))
	    							       (setq found t))
	    							      ((and (characterp input)
	    								    (characterp (row-major-aref alpha
													index))
	    								    (char= input
	    									   (row-major-aref alpha index)))
	    							       (setq found t))))
	    						      omega)
	    					   (setf (row-major-aref output index)
	    						 (if found 1 0))))
	    				       output))))
	       (tests (is "∊2 2 2⍴⍳9" #(1 2 3 4 5 6 7 8))
	    	      (is "2 5 7∊1 2 3 4 5" #(1 1 0))))
	    (↑ (has :titles ("Disclose" "Take"))
	       (ambivalent (args :any (lambda (omega)
	    				(if (or (not (vectorp omega))
	    					(not (arrayp (aref omega 0))))
	    				    omega (aref omega 0))))
	    		   (args :any :any :axes
	    			 (lambda (alpha omega &optional axes)
	    			   (multidim-slice omega (if axes
							     (loop for axis from 0 to (1- (rank omega))
								collect (if (= axis (- (aref (first axes) 0)
										       (of-state *apex-idiom*
												 :count-from)))
									    (aref alpha 0)
									    (nth axis (dims omega))))
							     (array-to-list alpha))
	    					   :fill-with 0))))
	       (tests (is "↑⊂1 2 3 4" #(1 2 3 4))
	    	      (is "2 3 4↑4 5 6⍴⍳9" #3A(((1 2 3 4) (7 8 9 1) (4 5 6 7))
	    				       ((4 5 6 7) (1 2 3 4) (7 8 9 1))))
		      (is "1↑[1]2 3 4⍴⍳9" #3A(((1 2 3 4) (5 6 7 8) (9 1 2 3))))
		      (is "1↑[2]2 3 4⍴⍳9" #3A(((1 2 3 4)) ((4 5 6 7))))
		      (is "2↑[2]2 3 4⍴⍳9" #3A(((1 2 3 4) (5 6 7 8)) ((4 5 6 7) (8 9 1 2))))
		      (is "2↑[3]2 3 4⍴⍳9" #3A(((1 2) (5 6) (9 1)) ((4 5) (8 9) (3 4))))))
	    (↓ (has :titles ("Drop" "Split"))
	       (ambivalent (args :any :axes (lambda (omega &optional axes)
	    				      ;; TODO: check this against another implementation
	    				      (aops:split omega (if axes (aref (first axes) 0)
	    							    (1- (rank omega))))))
	    		   (args :any :any :axes
	    			 (lambda (alpha omega &optional axes)
	    			   (multidim-slice omega
						   (if axes (loop for axis from 0 to (1- (rank omega))
							       collect (if (= axis (- (aref (first axes) 0)
										      (of-state *apex-idiom*
												:count-from)))
									   (aref alpha 0)
									   0))
						       (array-to-list alpha))
	    					   :inverse t))))
	       (tests (is "↓3 4⍴⍳9" #(#(1 2 3 4) #(5 6 7 8) #(9 1 2 3)))
	    	      (is "2 2 2↓4 5 6⍴⍳9" #3A(((3 4 5 6) (9 1 2 3) (6 7 8 9))
	    				       ((6 7 8 9) (3 4 5 6) (9 1 2 3))))
		      (is "1↓[1]2 3 4⍴⍳9" #3A(((4 5 6 7) (8 9 1 2) (3 4 5 6))))
		      (is "1↓[2]2 3 4⍴⍳9" #3A(((5 6 7 8) (9 1 2 3)) ((8 9 1 2) (3 4 5 6))))
		      (is "2↓[2]2 3 4⍴⍳9" #3A(((9 1 2 3)) ((3 4 5 6))))
		      (is "2↓[3]2 3 4⍴⍳9" #3A(((3 4) (7 8) (2 3)) ((6 7) (1 2) (5 6))))))
	    (⌷ (has :title "Axis")
	       (dyadic (args :any :any (lambda (alpha omega)
	    				 (let ((found (apply #'aref (cons omega
									  (mapcar (lambda (coord)
										    (- coord
										       (of-state *apex-idiom*
												 :count-from)))
										  (array-to-list alpha))))))
					   (if (not (arrayp found))
					       (vector found)
					       found)))))
	       (tests (is "3⌷⍳9" #(3))
		      (is "2 2⌷4 5⍴⍳9" #(7))
		      (is "2 3 4⌷4 5 6⍴⍳9" #(1))))
	    (\, (has :titles ("Ravel" "Catenate or Laminate"))
	    	(ambivalent (args :any (lambda (omega)
	    				 (if (vectorp omega)
	    				     omega (make-array (list (array-total-size omega))
							       :element-type (element-type omega)
	    						       :displaced-to (copy-array omega)))))
	    		    (args :any :any :axes
	    			  (lambda (alpha omega &optional axes)
	    			    (if (and (or (not axes)
						 (integerp (aref (first axes) 0)))
					     (vectorp alpha)
	    				     (vectorp omega))
	    				(if (and axes (< 0 (- (aref (first axes) 0)
							      (of-state *apex-idiom* :count-from))))
					    (error "Specified axis is greater than 1, vectors have only one axis along which to catenate.")

					    (if (and axes (> 0 (- (aref (first axes) 0)
								  (of-state *apex-idiom* :count-from))))
						(error (format nil "Specified axis is less than ~a."
							       (of-state *apex-idiom* :count-from)))
						(concatenate 'vector alpha omega)))
	    				(if (or (not axes)
						(integerp (aref (first axes) 0)))
					    (aops:stack (if axes (- (aref (first axes) 0)
								    (of-state *apex-idiom* :count-from))
							    1)
							alpha omega)
					    ;; laminate in the case of a fractional axis argument
					    ;; TODO: problems persist with laminate logic
					    (let ((axis (ceiling (- (aref (first axes) 0)
								    (of-state *apex-idiom* :count-from))))
						  (permute-dims (alexandria:iota (1+ (rank alpha)))))
					      (aops:stack axis
							  (aops:permute (rotate-right axis permute-dims)
									(array-promote alpha))
							  (aops:permute (rotate-right axis permute-dims)
									(array-promote omega)))))))))
	    	(tests (is ",3 4⍴⍳9" #(1 2 3 4 5 6 7 8 9 1 2 3))
	    	       (is "(3 6⍴⍳6),3 4⍴⍳9" #2A((1 2 3 4 5 6 1 2 3 4) (1 2 3 4 5 6 5 6 7 8)
	    					 (1 2 3 4 5 6 9 1 2 3)))
		       (is "(5 4⍴⍳6),[1]3 4⍴⍳9" #2A((1 2 3 4) (5 6 1 2) (3 4 5 6) (1 2 3 4)
						    (5 6 1 2) (1 2 3 4) (5 6 7 8) (9 1 2 3)))
		       (is "1 2 3,4 5 6" #(1 2 3 4 5 6))
		       (is "1 2 3,[1]4 5 6" #(1 2 3 4 5 6))
		       (is "1 2 3 4,[0.5]1 2 3 4" #2A((1 2 3 4) (1 2 3 4)))
		       (is "1 2 3 4,[1.5]1 2 3 4" #2A((1 1) (2 2) (3 3) (4 4)))
		       (is "(2 3⍴⍳9),[0.5]2 3⍴⍳9" #3A(((1 2 3) (4 5 6)) ((1 2 3) (4 5 6))))
		       (is "(2 3⍴⍳9),[2.5]2 3⍴⍳9" #3A(((1 1) (2 2) (3 3)) ((4 4) (5 5) (6 6))))))
     	    (⍪ (has :titles ("Table" "Catenate First"))
	       (ambivalent (args :any (lambda (omega) (if (vectorp omega)
	    						  (make-array (list (length omega) 1)
								      :element-type (element-type omega)
	    							      :initial-contents
	    							      (loop for i from 0 to (1- (length omega))
	    								 collect (list (aref omega i))))
	    						  (let ((o-dims (dims omega)))
							    (make-array (list (first o-dims)
									      (apply #'* (rest o-dims)))
									:element-type (element-type omega)
									:displaced-to (copy-array omega))))))
	    		   (args :any :any :axes
				 (lambda (alpha omega &optional axes)
				   (if (and (vectorp alpha)
					    (vectorp omega))
				       (if axes
					   (error "Axis arguments not accepted when catenating vectors.")
					   (concatenate 'vector alpha omega))
				       (aops:stack (if axes (- (aref (first axes) 0)
							       (of-state *apex-idiom* :count-from))
						       0)
						   alpha omega)))))
	       (tests (is "⍪'MAKE'" #2A((#\M) (#\A) (#\K) (#\E)))
		      (is "⍪3 4⍴⍳9" #2A((1 2 3 4) (5 6 7 8) (9 1 2 3)))
		      (is "⍪2 3 4⍴⍳24" #2A((1 2 3 4 5 6 7 8 9 10 11 12)
					   (13 14 15 16 17 18 19 20 21 22 23 24)))
	    	      (is "(5 4⍴⍳6)⍪3 4⍴⍳9" #2A((1 2 3 4) (5 6 1 2) (3 4 5 6) (1 2 3 4)
	    					(5 6 1 2) (1 2 3 4) (5 6 7 8) (9 1 2 3)))
		      (is "(3 6⍴⍳6)⍪[2]3 4⍴⍳9" #2A((1 2 3 4 5 6 1 2 3 4) (1 2 3 4 5 6 5 6 7 8)
						   (1 2 3 4 5 6 9 1 2 3)))))
	    (/ (has :title "Compress")
	       (dyadic (args :any :any :axes
	    		     (lambda (alpha omega &optional axes)
	    		       (expand-array (array-to-list alpha)
	    				     omega (if axes (- (rank omega)
	    						       (- (aref (first axes) 0)
	    							  (1- (of-state *apex-idiom* :count-from)))))
	    				     0 :compress-mode t))))
	       (tests (is "5/3" #(3 3 3 3 3))
		      (is "1 0 1 0 1/⍳5" #(1 3 5))
		      (is "3/⍳5" #(1 1 1))
		      (is "3/⊂⍳5" #(#(1 2 3 4 5) #(1 2 3 4 5) #(1 2 3 4 5)))
	    	      (is "1 ¯2 3 ¯4 5/3 5⍴⍳5" #2A((1 0 0 3 3 3 0 0 0 0 5 5 5 5 5)
						   (1 0 0 3 3 3 0 0 0 0 5 5 5 5 5)
						   (1 0 0 3 3 3 0 0 0 0 5 5 5 5 5)))
		      (is "1 ¯2 3/[1]3 5⍴⍳9" #2A((1 2 3 4 5) (0 0 0 0 0) (0 0 0 0 0)
						 (2 3 4 5 6) (2 3 4 5 6) (2 3 4 5 6)))))
	    (⌿ (has :title "Compress First")
	       (dyadic (args :any :any :axes
	    		     (lambda (alpha omega &optional axes)
	    		       (expand-array (array-to-list alpha)
	    				     omega (if axes (- (rank omega)
	    						       (- (aref (first axes) 0)
	    							  (1- (of-state *apex-idiom* :count-from)))))
	    				     (1- (rank omega))
	    				     :compress-mode t))))
	       (tests (is "1 0 1 0 1⌿⍳5" #(1 3 5))
		      (is "1 ¯2 3⌿3 5⍴⍳9" #2A((1 2 3 4 5) (0 0 0 0 0) (0 0 0 0 0)
					      (2 3 4 5 6) (2 3 4 5 6) (2 3 4 5 6)))
		      (is "1 ¯2 3 ¯4 5⌿[2]3 5⍴⍳5" #2A((1 0 0 3 3 3 0 0 0 0 5 5 5 5 5)
						      (1 0 0 3 3 3 0 0 0 0 5 5 5 5 5)
						      (1 0 0 3 3 3 0 0 0 0 5 5 5 5 5)))))
	    (\\ (has :title "Expand")
	    	(dyadic (args :any :any :axes
	    		      (lambda (alpha omega &optional axes)
	    			(expand-array (array-to-list alpha)
	    				      omega (if axes (- (rank omega)
	    							(- (aref (first axes) 0)
	    							   (1- (of-state *apex-idiom* :count-from)))))
	    				      0))))
		(tests (is "1 ¯2 3 ¯4 5\\ '.'" ".  ...    .....")
		       (is "1 ¯2 2 0 1\\3+2 3 ⍴⍳6" #2A((4 0 0 5 5 0 6) (7 0 0 8 8 0 9)))
		       (is "1 0 1\\[1]3+2 3 ⍴⍳6" #2A((4 5 6) (0 0 0) (7 8 9)))))
	    (⍀ (has :title "Expand First")
	       (dyadic (args :any :any :axes
	    		     (lambda (alpha omega &optional axes)
	    		       (expand-array (array-to-list alpha)
	    				     omega (if axes (- (rank omega)
	    						       (- (aref (first axes) 0)
	    							  (1- (of-state *apex-idiom* :count-from)))))
	    				     (1- (rank omega))))))
	       (tests (is "1 ¯2 3 ¯4 5⍀3" #(3 0 0 3 3 3 0 0 0 0 3 3 3 3 3))
		      (is "1 0 1⍀3+2 3 ⍴⍳6" #2A((4 5 6) (0 0 0) (7 8 9)))))
	    (⍷ (has :title "Find")
	       (dyadic (args :any :any find-array))
	       (tests (is "(2 2⍴6 7 1 2)⍷2 3 4⍴⍳9" #3A(((0 0 0 0) (0 1 0 0) (0 0 0 0))
						       ((0 0 1 0) (0 0 0 0) (0 0 0 0))))))
	    (⊂ (has :titles ("Enclose" "Partition"))
	       ;; TODO: add multi-axis option
	       (ambivalent (args :any :axes
				 (lambda (omega &optional axes)
				   (if axes
				       (aops:split (aops:permute (sort (alexandria:iota (rank omega))
								       (lambda (a b)
									 (declare (ignore a))
									 (= b (- (aref (first axes) 0)
										 (of-state *apex-idiom*
											   :count-from)))))
								 omega)
						   (1- (rank omega)))
				       (if (loop for dim in (dims omega) always (= 1 dim))
					   omega (make-array (list 1) :initial-element omega)))))
	    		   (args :any :any (lambda (alpha omega)
	    				     (if (/= (length alpha) (length omega))
	    					 (error "Length mismatch.")
	    					 (let ((output nil)
	    					       (accumulator nil)
	    					       (partition-index 0))
	    					   (dotimes (index (length alpha))
	    					     (if (and (< 0 index)
	    						      (< partition-index (aref alpha index)))
	    						 (progn (setq output
	    							      (cons (make-array (list (length accumulator))
	    										:initial-contents
	    										(reverse accumulator))
	    								    output))
	    							(setq accumulator nil)))
	    					     (setq partition-index (aref alpha index))
	    					     (if (< 0 (aref alpha index))
	    						 (setq accumulator (cons (aref omega index)
	    									 accumulator))))
	    					   (if accumulator (setq output
	    								 (cons (make-array
	    									(list (length accumulator))
	    									:initial-contents
	    									(reverse accumulator))
	    								       output)))
	    					   (make-array (list (length output))
	    						       :initial-contents (reverse output)))))))
	       (tests (is "⊂3 4⍴⍳7" #(#2A((1 2 3 4) (5 6 7 1) (2 3 4 5))))
		      (is "⊂[3]2 3 4⍴'GRAYGOLDBLUESILKWOOLYARN'"
			  #2A(("GRAY" "GOLD" "BLUE") ("SILK" "WOOL" "YARN")))
		      (is "⊂[2]2 3 4⍴'GRAYGOLDBLUESILKWOOLYARN'"
			  #2A(("GGB" "ROL" "ALU" "YDE") ("SWY" "IOA" "LOR" "KLN")))
		      (is "⊂[1]2 3 4⍴'GRAYGOLDBLUESILKWOOLYARN'"
			  #2A(("GS" "RI" "AL" "YK") ("GW" "OO" "LO" "DL") ("BY" "LA" "UR" "EN")))
	    	      (is "1 1 2 2 2 3 3 3 3⊂⍳9" #(#(1 2) #(3 4 5) #(6 7 8 9)))))
	    (⊃ (has :titles ("Mix" "Pick"))
	       (ambivalent (args :any :axes
				 (lambda (omega &optional axes)
				   (mix-arrays (if axes (ceiling (- (1+ (rank omega))
								    (aref (first axes) 0)
								    (of-state *apex-idiom* :count-from)))
						   0)
					       omega)))
	    		   (args :any :any (lambda (alpha omega)
					     (labels ((layer-index (object indices)
							(if indices
							    (layer-index (aref object (- (first indices)
											 (of-state *apex-idiom*
												   :count-from)))
									 (rest indices))
							    object)))
					       (let ((found (layer-index omega (array-to-list alpha))))
						 (if (arrayp found)
						     found (make-array (list 1)
								       :element-type (element-type omega)
								       :initial-element found)))))))
	       (tests (is "⊃(1)(1 2)(1 2 3)" #2A((1 0 0) (1 2 0) (1 2 3)))
		      (is "⊃[0.5](1)(1 2)(1 2 3)" #2A((1 1 1) (0 2 2) (0 0 3)))
		      (is "⊃(2 3⍴⍳5)(4 2⍴⍳8)" #3A(((1 2 3) (4 5 1) (0 0 0) (0 0 0))
						  ((1 2 0) (3 4 0) (5 6 0) (7 8 0))))
		      (is "⊃[0.5](2 3⍴⍳5)(4 2⍴⍳8)" #3A(((1 4 0 0) (1 3 5 7)) ((2 5 0 0) (2 4 6 8))
						       ((3 1 0 0) (0 0 0 0))))
		      (is "⊃[1.5](2 3⍴⍳5)(4 2⍴⍳8)" #3A(((1 2 3) (4 5 1) (0 0 0) (0 0 0))
						       ((1 2 0) (3 4 0) (5 6 0) (7 8 0))))
		      (is "⊃2 2 2⍴(1)(1 2)(3 4)(1 2 3)" #4A((((1 0 0) (1 2 0)) ((3 4 0) (1 2 3)))
							    (((1 0 0) (1 2 0)) ((3 4 0) (1 2 3)))))
		      (is "2⊃(1 2 3)(4 5 6)(7 8 9)" #(4 5 6))
		      (is "(2 2)⊃(1 2 3)(4 5 6)(7 8 9)" #(5))))
	    (∪ (has :titles ("Unique" "Union"))
	       (ambivalent (args :any (lambda (omega)
	    				(if (not (vectorp omega))
	    				    (error "Argument must be a vector.")
	    				    (let ((uniques nil))
	    				      (dotimes (index (length omega))
	    					(if (not (find (aref omega index)
	    						       uniques))
	    					    (setq uniques (cons (aref omega index)
	    								uniques))))
	    				      (make-array (list (length uniques))
							  :element-type (element-type omega)
	    						  :initial-contents (reverse uniques))))))
	    		   (args :any :any (lambda (alpha omega)
	    				     (if (or (not (vectorp alpha))
	    					     (not (vectorp omega)))
	    					 (error "Arguments must be vectors.")
	    					 (let ((uniques nil))
	    					   (dotimes (index (length omega))
	    					     (if (not (find (aref omega index)
	    							    alpha))
	    						 (setq uniques (cons (aref omega index)
	    								     uniques))))
	    					   (concatenate 'vector alpha
	    							(make-array (list (length uniques))
									    :element-type (element-type alpha)
	    								    :initial-contents
	    								    (reverse uniques))))))))
	       (tests (is "∪1 2 3 4 5 1 2 8 9 10 11 7 8 11 12" #(1 2 3 4 5 8 9 10 11 7 12))
		      (is "∪'MISSISSIPPI'" "MISP")
		      ;; TODO: is behavior below correct?
		      (is "3 10 14 18 11∪9 4 5 10 8 3" #(3 10 14 18 11 9 4 5 8))
		      (is "'STEEL'∪'SABER'" "STEELABR")))
	    (∩ (has :title "Intersection")
	       (dyadic (args :any :any (lambda (alpha omega)
	    				 (if (or (not (vectorp alpha))
	    					 (not (vectorp omega)))
	    				     (error "Arguments must be vectors.")
	    				     (let ((matches nil))
	    				       (dotimes (index (length alpha))
	    					 (if (find (aref alpha index)
	    						   omega)
	    					     (setq matches (cons (aref alpha index)
	    								 matches))))
	    				       (make-array (list (length matches))
							   :element-type (element-type alpha)
	    						   :initial-contents (reverse matches)))))))
	       (tests (is "'MIXTURE'∩'LATER'" "TRE")
		      (is "'STEEL'∩'SABER'" "SEE")
		      (is "1 4 8∩⍳5" #(1 4))))
	    (⌽ (has :titles ("Reverse" "Rotate"))
	       (ambivalent (args :any :axes (lambda (omega &optional axes)
	    				      (if (vectorp omega)
	    					  (let ((new-array (copy-array omega)))
	    					    (funcall (make-rotator)
	    						     new-array)
	    					    new-array)
	    					  (if (arrayp omega)
	    					      (apply-marginal (make-rotator)
	    							      omega (if axes (1- (aref (first axes) 0)))
	    							      (1- (rank omega)))))))
	    		   (args :one :any :axes
	    			 (lambda (alpha omega &optional axes)
	    			   (if (vectorp omega)
	    			       (let ((new-array (copy-array omega)))
	    				 (funcall (make-rotator alpha)
	    					  new-array)
	    				 new-array)
	    			       (if (arrayp omega)
	    				   (apply-marginal (make-rotator alpha)
	    						   omega (if axes (1- (aref (first axes) 0)))
	    						   (1- (rank omega))))))))
	       (tests (is "⌽1 2 3 4 5" #(5 4 3 2 1))
	    	      (is "⌽3 4⍴⍳9" #2A((4 3 2 1) (8 7 6 5) (3 2 1 9)))
	    	      (is "2⌽3 4⍴⍳9" #2A((3 4 1 2) (7 8 5 6) (2 3 9 1)))))
     	    (⊖ (has :titles ("Reverse First" "Rotate First"))
	       (ambivalent (args :any :axes (lambda (omega &optional axes)
	    				      (if (vectorp omega)
	    					  (let ((new-array (copy-array omega)))
	    					    (funcall (make-rotator)
	    						     new-array)
	    					    new-array)
	    					  (if (arrayp omega)
	    					      (apply-marginal (make-rotator)
	    							      omega (if axes (1- (aref (first axes) 0)))
	    							      0)))))
	    		   (args :one :any :axes
	    			 (lambda (alpha omega &optional axes)
	    			   (if (vectorp omega)
	    			       (let ((new-array (copy-array omega)))
	    				 (funcall (make-rotator alpha)
	    					  new-array)
	    				 new-array)
	    			       (if (arrayp omega)
	    				   (apply-marginal (make-rotator alpha)
	    						   omega (if axes (1- (aref (first axes) 0)))
	    						   0))))))
	       (tests (is "⊖1 2 3 4 5" #(5 4 3 2 1))
	    	      (is "⊖3 4⍴⍳9" #2A((9 1 2 3) (5 6 7 8) (1 2 3 4)))
	    	      (is "1⊖3 4⍴⍳9" #2A((5 6 7 8) (9 1 2 3) (1 2 3 4)))))
	    (⍉ (has :titles ("Transpose" "Permute"))
	       (ambivalent (args :any (lambda (omega)
	    				(aops:permute (reverse (alexandria:iota (rank omega)))
	    					      omega)))
	    		   (args :any :any (lambda (alpha omega)
	    				     (aops:permute (mapcar (lambda (i)
	    							     (- i (of-state *apex-idiom* :count-from)))
	    							   (array-to-list alpha))
	    						   omega))))
	       (tests (is "⍉2 3 4⍴⍳9" #3A(((1 4) (5 8) (9 3)) ((2 5) (6 9) (1 4))
					  ((3 6) (7 1) (2 5)) ((4 7) (8 2) (3 6))))
		      (is "1 3 2⍉2 3 4⍴⍳9" #3A(((1 5 9) (2 6 1) (3 7 2) (4 8 3))
					       ((4 8 3) (5 9 4) (6 1 5) (7 2 6))))))
	    ;; TODO: left inversion for non-square matrices is nyi
	    (⌹ (has :titles ("Matrix Inverse" "Matrix Divide"))
	       (ambivalent (args :any (lambda (omega)
	    				(if (and (= 1 (rank omega))
	    					 (= 1 (length omega)))
	    				    (/ (aref omega 0))
	    				    (invert-matrix omega))))
	    		   (args :any :any (lambda (alpha omega)
					     (array-inner-product (invert-matrix omega)
								  alpha (lambda (arg1 arg2)
									  (apply-scalar-dyadic #'* arg1 arg2))
								  #'+))))
	       (tests (is "⌹2 2⍴4 9 8 2" #2A((-1/32 9/64) (1/8 -1/16)))
		      (is "35 89 79⌹3 3⍴3 1 4 1 5 9 2 6 5" #(193/90 739/90 229/45))
		      (is "(3 2⍴1 2 3 6 9 10)⌹3 3⍴1 0 0 1 1 0 1 1 1" #2A((1 2) (2 4) (6 4)))))
	    (⍋ (has :titles ("Grade Up" "Grade Up By"))
	       (ambivalent (args :any (lambda (omega) (grade omega (alpha-compare (of-state *apex-idiom*
	    										    :atomic-vector)
	    									  #'<=)
							     (of-state *apex-idiom* :count-from))))
	    		   (args :any :any (lambda (alpha omega) (grade (if (vectorp alpha)
									    (index-of alpha omega)
									    (array-grade alpha omega))
	    								(alpha-compare (of-state *apex-idiom*
	    											 :atomic-vector)
	    									       #'<)
									(of-state *apex-idiom* :count-from)))))
	       (tests (is "⍋8 3 4 9 1 5 2" #(5 7 2 3 6 1 4))
		      (is "⍋5 6 ⍴⍳16" #(1 4 2 5 3))
		      (is "(2 5⍴'ABCDEabcde')⍋'ACaEed'" #(1 3 2 6 4 5))))
	    (⍒ (has :titles ("Grade Down" "Grade Down By"))
	       (ambivalent (args :any (lambda (omega) (grade omega (alpha-compare (of-state *apex-idiom*
	    										    :atomic-vector)
	    									  #'>=)
							     (of-state *apex-idiom* :count-from))))
	    		   (args :any :any (lambda (alpha omega) (grade (if (vectorp alpha)
									    (index-of alpha omega)
									    (array-grade alpha omega))
	    								(alpha-compare (of-state *apex-idiom*
	    											 :atomic-vector)
	    									       #'>)
									(of-state *apex-idiom* :count-from)))))
	       (tests (is "⍒6 1 8 2 4 3 9" #(7 3 1 5 6 4 2))
		      (is "⍒5 6 ⍴⍳12" #(2 4 1 3 5))
		      (is "(2 5⍴'ABCDEabcde')⍒'ACaEed'" #(5 4 6 2 3 1))))
	    (⊤ (has :title "Encode")
	       (dyadic (args :any :any (lambda (alpha omega)
	    				 (flet ((rebase (bases number)
	    					  (let ((operand number)
	    						(last-base 1)
	    						(base 1)
	    						(component 1)
	    						(element nil))
	    					    (loop for index from (1- (length bases)) downto 0
	    					       do (setq last-base base
	    							base (* base (aref bases index))
	    							component (if (= 0 base)
	    								      operand
	    								      (* base
	    									 (nth-value 1 (floor (/ operand
	    												base)))))
	    							operand (- operand component)
	    							element (/ component last-base))
	    					       collect element))))
	    				   (if (= 1 (length omega))
	    				       (let ((result (rebase alpha (aref omega 0))))
	    					 (make-array (list (length result))
	    						     :initial-contents (reverse result)))
	    				       (aops:permute (list 1 0)
	    						     (make-array (list (length omega) (length alpha))
	    								 :initial-contents
	    								 (mapcar (lambda (item)
	    									   (reverse (rebase alpha item)))
	    									 (array-to-list omega)))))))))
	       (tests (is "1760 3 12⊤82" #(2 0 10))
		      (is "16 16 16 16⊤100" #(0 0 6 4))
		      (is "2 2 2 2 2⊤1 2 3 4 5" #2A((0 0 0 0 0) (0 0 0 0 0) (0 0 0 1 1)
						    (0 1 1 0 0) (1 0 1 0 1)))))
	    (⊥ (has :title "Decode")
	       (dyadic (args :any :any (lambda (alpha omega)
	    				 (flet ((rebase (bases numerators)
	    					  (let ((result 0)
	    						(base 1))
	    					    (loop for index from (1- (length numerators)) downto 0
	    					       do (incf result (* base (aref numerators index)))
	    						 (setf base (* base (aref bases index))))
	    					    result)))
	    				   (let ((bases (if (= 1 (length alpha))
	    						    (make-array (list (first (dims omega)))
	    								:initial-element (aref alpha 0))
	    						    (if (not (= (length alpha)
	    								(let ((d-o (dims omega)))
	    								  (if (= 1 (length d-o))
	    								      (first d-o)
	    								      (second d-o)))))
	    							(error "Base/element length mismatch.")
	    							alpha))))
	    				     (if (= 1 (rank omega))
	    					 (vector (rebase bases omega))
	    					 (aops:margin (lambda (sub-array) (rebase bases sub-array))
	    						      omega 0)))))))
	       (tests (is "10⊥2 6 7 1" #(2671))
		      (is "1760 3 12⊥2 2 5" #(101))
		      (is "1760 3 12⊥3 3⍴1 2 1 5 0 2 2 3 7" #(98 75 67))))
	    (⍎ (has :title "Evaluate")
	       (monadic (macro (lambda (meta axes omega)
				 (declare (ignore meta axes))
				 `(apex ,omega))))
	       (tests (is "⍎'1+1'" #(2))))
	    (∘ (has :title "Find Outer Product, Not Inner")
	       (symbolic :outer-product-designator)))
 (general-tests (with :title "Basic function definition and use, with comments."
		      :in ("⍝ This code starts with a comment.
                            f1←{⍵+3} ◊ f2←{⍵×2} ⍝ A comment after the functions are defined.
                            ⍝ This is another comment.
                            f2 f1 1 2 3 4 5")
		      :ex #(8 10 12 14 16))
		(with :title "Monadic inline function."
		      :in ("{⍵+3} 3 4 5")
		      :ex #(6 7 8))
		(with :title "Dyadic inline function."
		      :in ("1 2 3 {⍺×⍵+3} 3 4 5")
		      :ex #(6 14 24))
		(with :title "Variable-referenced values, including a component specified by axes, in a vector."
		      :in ("a←9 ◊ b←2 3 4⍴⍳9 ◊ 1 2 a 3 b[1;2;1]")
		      :ex #(1 2 9 3 4))))
