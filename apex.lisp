;;;; apex.lisp

(in-package #:apex)

(defclass idiom ()
  ((name :accessor idiom-name
	 :initarg :name)
   (environment :accessor idiom-environment
		:initarg :environment)
   (parsers :accessor idiom-parsers
	    :initform ""
	    :initarg :function-matcher)
   (functions :accessor idiom-functions
	      :initform nil
	      :initarg :functions)
   (operators :accessor idiom-operators
	      :initform nil
	      :initarg :operators)
   (operational-glyphs :accessor idiom-opglyphs
		       :initform nil
		       :initarg :operational-glyphs)
   (operator-index :accessor idiom-opindex
		   :initform nil
		   :initarg :operator-index)
   (overloadex-lexicon :accessor idiom-overloaded-lexicon
		       :initform nil
		       :initarg :overloaded-lexicon)))

(defgeneric of-environment (idiom property))
(defmethod of-environment ((idiom idiom) property)
  (getf (idiom-environment idiom) property))

(defun handle-argument (operation omega &optional alpha)
  (if (and (symbolp (first operation))
	   (macro-function (first operation))
	   (not (eql 'lambda (first operation))))
      (cond ((eql 'args (first operation))
	     (macroexpand (append (cons 'args (last operation))
				  (cons (second operation)
					(append (if (keywordp (third operation))
						    (list (third operation))
						    ;; the placeholder is added in case of (args :scalar ...)
						    ;; and other macros which have two arguments but only one
						    ;; structure-specifying parameter
						    (if alpha (list :placeholder)))
						(if (keywordp (fourth operation))
						    (list (fourth operation))))))))
	    (t (macroexpand (append operation (cons omega (if alpha (list alpha)))))))
      `(quote ,operation)))

(defmacro ambivalent (operation second-operation &optional third-input)
  `((if alpha
	,(handle-argument (if (eq :symmetric-scalar operation)
			      (list 'args :scalar second-operation)
			      (if (eq :asymmetric-scalar operation)
				  (list 'args :scalar third-input)
				  second-operation))
			  'omega 'alpha)
	,(handle-argument (if (eq :symmetric-scalar operation)
			      (list 'args :scalar second-operation)
			      (if (eq :asymmetric-scalar operation)
				  (list 'args :scalar second-operation)
				  operation))
			  'omega))))

(defmacro monadic (operation)
  `((if alpha
	`(progn (error "Valence error - monadic operation."))
	,(handle-argument operation 'omega))))

(defmacro dyadic (operation)
  `((if alpha
	,(handle-argument operation 'omega 'alpha)
	`(error "Valence error - dyadic operation."))))

(defmacro args (operation omega &optional alpha axes)
  "Moderate arguments to a Vex function at compile time."
  (let ((fn (if (and (listp operation)
		     (macro-function (first operation))
		     (not (eql 'lambda (first operation))))
		(macroexpand (append operation (if alpha (list 'omega 'alpha)
						   (list 'omega))))
		``(function ,',operation))))
    (if (eq omega :scalar)
	`(if alpha
	     `(apply-scalar-function ,,fn ,(macroexpand omega)
				     ,(macroexpand alpha))
	     `(aops:each ,,fn ,(macroexpand omega)))
	``(if (and ,(if (eq :any ,omega)
			t (cond ((eq :one ,omega)
				 `(is-singleton ,(macroexpand omega)))
				((eq :sym ,omega)
				 (if (eql 'lambda (first alpha))
				     (setf (gethash :functions meta)
				 	   (cons (macroexpand omega)
						 (gethash :functions meta))))
				 `(symbolp (quote ,(if (listp (macroexpand omega))
						       (second (getf (macroexpand omega)
								     :initial-contents))
						       (macroexpand omega)))))))
		   ,@(if (and ,alpha (not (eq :any ,alpha)))
			 (if (eq :one ,alpha)
			     (list `(is-singleton ,(macroexpand alpha))))))
	      ;; if the arguments are scalar (:one), remove them from their arrays for evaluation
	      (funcall ,,fn ,(cond ((eq :one ,omega)
				    `(if (arrayp ,(macroexpand omega))
					 (aref ,(macroexpand omega) 0)
					 ,(macroexpand omega)))
				   ((eq :sym ,omega)
				    `(quote ,(if (listp (macroexpand omega))
						 (second (getf (macroexpand omega)
							       :initial-contents))
						 (macroexpand omega))))
				   (t (macroexpand omega)))
		       ,@(if ,alpha (list (cond ((eq :one ,alpha)
						 `(aref ,(macroexpand alpha) 0))
						((eq :axes ,alpha)
						 (cons 'list (macroexpand axes)))
						;; alpha is equal to :axes when
						;; axes are used for a monadic function
						(t (macroexpand alpha)))))
		       ,@(if ,axes (list (cons 'list (macroexpand axes)))))))))

(defmacro boolean-op (operation omega &optional alpha)
  "Converts output of a boolean operation from t/nil to 1/0."
  `(lambda ,(if alpha (list omega alpha)
  		(list omega))
     (if (funcall (function ,operation)
  		  ,@(if alpha (list omega alpha)
  			(list omega)))
  	 1 0)))

(defmacro vex-spec (symbol &rest subspecs)
  "Process the specification for a vector language and build functions that generate the code tree."
  (labels ((process-function-definition (is-dyadic is-scalar function-spec)
	     (let ((discrete-function (if (and (listp (first function-spec))
					       (macro-function (caar function-spec))
					       (not (eql 'lambda (caar function-spec))))
					  (macroexpand (append (first function-spec)
							       (cons 'omega (if is-dyadic (list 'alpha)))))
					  (cons 'function function-spec))))
	       (if (not is-scalar)
		   discrete-function
		   `(lambda ,(if is-dyadic (list 'alpha 'omega)
				 (list 'omega))
		      ,(if is-dyadic `(apply-scalar-function ,discrete-function alpha omega)
			   `(if (arrayp omega)
				(aops:each ,discrete-function omega)
				(funcall ,discrete-function omega)))))))

	   (assign-discrete-functions (specs)
	     ;; return a list containing the function, or both functions if ambivalent
	     (let ((spec (second specs)))
	       (if (eql 'monadic (first spec))
		   (list (process-function-definition nil (eq :scalar (cadadr spec))
						      (last (first (last spec)))))
		   (if (eql 'dyadic (first spec))
		       (list (process-function-definition t (eq :scalar (cadadr spec))
							  (last (first (last spec)))))
		       (list (if (listp (second spec))
				 (process-function-definition nil (or (eq :symmetric-scalar (second spec))
								      (eq :scalar (cadadr spec)))
							      (last (second spec)))
				 (process-function-definition
				  nil t
				  (if (eq :symmetric-scalar (second spec))
				      (last spec)
				      (list (third spec)))))
			     (if (listp (second spec))
				 (process-function-definition t (eq :scalar (second (third spec)))
							      (last (third spec)))
				 (process-function-definition t (or (eq :symmetric-scalar
									(second spec))
								    (eq :asymmetric-scalar
									(second spec)))
							      (last spec))))))))

	   (process-pairs (table-symbol pairs &optional output)
	     (if pairs
		 (process-pairs table-symbol (cddr pairs)
				(let* ((glyph-char (character (first pairs)))
				       (accumulator (third output)))
				  (if (and (eql 'op-specs table-symbol))
				      (setf (getf accumulator (intern (string-upcase (caadr pairs))
								      "KEYWORD"))
					    (cons 'list (cons glyph-char (rest (getf accumulator
										     (intern (string-upcase
											      (caadr pairs))
											     "KEYWORD")))))))
				  (list (cons glyph-char (first output))
					(append (second output)
						(cond ((and (eql 'fn-specs table-symbol)
							    (eql 'symbolic (caadr pairs)))
						       ;; assign symbolic functions as just keywords in the table
						       `((gethash ,glyph-char ,table-symbol)
							 ,(cadadr pairs)))
						      ;; assign functions in hash table
						      ((eql 'fn-specs table-symbol)
						       `((gethash ,glyph-char ,table-symbol)
							 (list (lambda (meta axes omega &optional alpha)
								 (declare (ignorable meta axes alpha))
								 ,@(macroexpand (second pairs)))
							       ,@(assign-discrete-functions pairs))))
						      ;; assign operators in hash table
						      ((eql 'op-specs table-symbol)
						       `((gethash ,glyph-char ,table-symbol)
							 ,(if (eql 'macro (first (cadadr pairs)))
							      (macroexpand (second (cadadr pairs)))
							      `(lambda (meta axes functions operand
									&optional right-operand)
								 (declare (ignorable meta axes right-operand))
								 `(funcall ,',(cadadr pairs)
									   ,(cons 'list axes)
									   ,(if (listp (first functions))
										(cons 'list
										      (mapcar (lambda (f)
												(if (listp f)
												    (cons 'list
													  (rest f))
												    f))
											      functions))
									   	(cons 'list (cdar functions)))
									   ,operand
									   ,@(if right-operand
										 (list right-operand)))))))))
					
					accumulator)))
		 output)))
    (let* ((function-specs (process-pairs 'fn-specs (rest (assoc (intern "FUNCTIONS" (package-name *package*))
								 subspecs))))
	   (operator-specs (process-pairs 'op-specs (rest (assoc (intern "OPERATORS" (package-name *package*))
								 subspecs)))))
      `(progn (defvar *vex-idiom*)
	      (let ((fn-specs (make-hash-table))
		    (op-specs (make-hash-table)))
		(setf ,@(second function-specs)
		      ,@(second operator-specs))
		(setq *vex-idiom* (make-instance 'idiom
						 :name ,(intern (string-upcase symbol) "KEYWORD")
						 :environment ,(cons 'list
								     (rest (assoc (intern "ENVIRONMENT"
											  (package-name *package*))
										  subspecs)))
						 :operational-glyphs (list ,@(derive-opglyphs
									      (append (first function-specs)
										      (first operator-specs))))
						 :functions fn-specs
						 :operators op-specs
						 :overloaded-lexicon (list ,@(intersection (first function-specs)
											   (first operator-specs)))
						 :operator-index (list ,@(third operator-specs))))

		(defmacro ,(intern (string-upcase symbol)
				   (package-name *package*))
		    (options &optional input-string)
		  (vex-program *vex-idiom* (if input-string options)
			       (if input-string input-string options))))))))

(defun derive-opglyphs (glyph-list &optional output)
  (if (not glyph-list)
      output (derive-opglyphs (rest glyph-list)
			      (let ((glyph (first glyph-list)))
				(if (characterp glyph)
				    (cons glyph output)
				    (if (stringp glyph)
					(append output (loop for char from 0 to (1- (length glyph))
							  collect (aref glyph char)))))))))

(defun numeric-string-p (string)
  (handler-case (progn (parse-apl-number-string string) t)
    (condition () nil)))

(defun parse-apl-number-string (number-string &optional imaginary-component)
  (let ((nstring (string-upcase number-string)))
    (if (and (not imaginary-component)
	     (find #\J nstring))
	(let ((halves (cl-ppcre:split "J" nstring)))
	  (if (and (= 2 (length halves))
		   (< 0 (length (first halves)))
		   (< 0 (length (second halves))))
	      (complex (parse-apl-number-string (first halves) t)
		       (parse-apl-number-string (second halves) t))))
	;; either the macron or combining_macron character may be used as the high minus sign
	(parse-number:parse-number (regex-replace-all "[¯̄]" nstring "-")))))

(defun format-array (values)
  (if (or (stringp (first values))
	  (symbolp (first values))
	  (and (not (second values))
	       (or (listp (first values))
		   (functionp (first values)))))
      ;; if the first item is a list (i.e. code to generate an array of some kind),
      ;; pass it through with no changes. Also pass through strings, which are already arrays,
      ;; any symbols
      (first values)
      `(make-array (list ,(length values))
		   :initial-contents (list ,@values))))

(defun format-function (content)
  `(lambda (⍺ &optional ⍵)
     ;; kludge to handle reversing the variable order
     ;; the latter variable is always the optional one in Lisp, but in APL
     ;; the ⍺ is the optional argument
     (if ⍵ (funcall (lambda (⍺ ⍵) ,content) ⍵ ⍺)
	   (funcall (lambda (⍵) ,content) ⍺))))

(defun format-value (element)
  (cond ((and (vectorp element)
	      (string= element "⍬")) ;; APL's "zilde" character translates to an empty vector
 	 (make-array (list 0)))
	((numeric-string-p element)
	 (parse-apl-number-string element))
	((or (and (char= #\" (aref element 0))
		  (char= #\" (aref element (1- (length element)))))
	     (and (char= #\' (aref element 0))
		  (char= #\' (aref element (1- (length element))))))
	 (subseq element 1 (1- (length element))))
	((stringp element)
	 (intern (string-upcase (symbol-munger:camel-case->lisp-name element))))
	(t element)))

(defun swap! (v i j)
  (let ((tt (aref v i)))
    (setf (aref v i)
	  (aref v j))
    (setf (aref v j) tt)))

(defun reverse! (v lo hi)
  (when (< lo hi)
    (swap! v lo hi)
    (reverse! v (+ lo 1) (- hi 1))))

(defun rotate! (n v)
  (let* ((len (length v))
	 (n (mod n len)))
    (reverse! v 0 (- n 1))
    (reverse! v n (- len 1))
    (reverse! v 0 (- len 1))))

(defun make-rotator (&optional degrees)
  (lambda (vector)
    (if degrees (rotate! degrees vector)
	(reverse! vector 0 (1- (length vector))))))

(defun rot-left(n l)
  (append (nthcdr n l) (butlast l (- (length l) n))))

(defun rot-right(n l)
  (rot-left (- (length l) n) l))

(defun rotate-array-horizontal (array &optional degrees)
  (let* ((adims (dims array))
	 (new-array (alexandria:copy-array array))
	 (axis-length (if (second adims) (second adims) (first adims))))
    (dotimes (index (if (second adims) (first adims) 1))
      (let ((displaced-array (make-array (list axis-length)
					 :displaced-to new-array
					 :displaced-index-offset (* index axis-length))))
	(if degrees (rotate! degrees displaced-array)
	    (reverse! displaced-array 0 (1- axis-length)))))
    new-array))

(defun rotate-array-vertical (array &optional degrees)
  (let* ((adims (dims array))
	 (axis-length (second adims))
	 (axis-height (first adims))
	 (row-list (make-array (list axis-height) :initial-contents (alexandria:iota axis-height)))
	 (new-array (alexandria:copy-array array)))
    (if degrees (rotate! degrees row-list)
	(reverse! row-list 0 (1- axis-height)))
    (dotimes (index (1- axis-height))
      (dotimes (sub-index (1- axis-length))
	(setf (aref new-array index sub-index)
	      (aref array (aref row-list index)
		    sub-index))))
    new-array))

(defun reshape-array-fitting (array adims)
  (let* ((original-length (array-total-size array))
	 (total-length (apply #'* adims))
	 (displaced-array (make-array (list original-length) :displaced-to array)))
    (aops:reshape (make-array (list total-length)
			      :initial-contents (loop for index from 0 to (1- total-length)
						   collect (aref displaced-array (mod index original-length))))
		  adims)))

(defun sprfact (n) ; recursive factorial-computing function based on P. Luschny's code
  (let ((p 1) (r 1) (NN 1) (log2n (floor (log n 2)))
	(h 0) (shift 0) (high 1) (len 0))
    (labels ((prod (n)
	       (declare (fixnum n))
	       (let ((m (ash n -1)))
		 (cond ((= m 0) (incf NN 2))
		       ((= n 2) (* (incf NN 2)
				   (incf NN 2)))
		       (t (* (prod (- n m))
			     (prod m)))))))
      (loop while (/= h n) do
	   (incf shift h)
	   (setf h (ash n (- log2n)))
	   (decf log2n)
	   (setf len high)
	   (setf high (if (oddp h)
			  h (1- h)))
	   (setf len (ash (- high len) -1))
	   (cond ((> len 0)
		  (setf p (* p (prod len)))
		  (setf r (* r p)))))
      (ash r shift))))

(defun is-singleton (value)
  (let ((adims (dims value)))
    (and (= 1 (first adims))
	 (= 1 (length adims)))))

(defun scale-array (singleton to-match)
  (make-array (dims to-match)
	      :initial-element (aref singleton 0)))

(defun apply-scalar-function (function alpha omega)
  (let* ((alpha-unitary? (or (and (vectorp alpha)
				  (= 1 (length alpha))
				  (not (arrayp (aref alpha 0))))
			     (not (arrayp alpha))))
	 (omega-unitary? (or (and (vectorp omega)
				  (= 1 (length omega))
				  (not (arrayp (aref omega 0))))
			     (not (arrayp omega)))))
    (if (and alpha-unitary? omega-unitary?)
	(if (or (arrayp alpha) (arrayp omega))
	    (aops:each function
		       (if (arrayp alpha)
			   alpha (make-array (list 1) :initial-element alpha))
		       (if (arrayp omega)
			   omega (make-array (list 1) :initial-element omega)))
	    (funcall function alpha omega))
	(if (not (or alpha-unitary? omega-unitary?))
	    (if (loop for dimension in (funcall (lambda (a o) (mapcar #'= a o))
						(dims alpha)
						(dims omega))
		   always dimension)
		(aops:each ;;(lambda (alpha omega) (apply-scalar-function function alpha omega))
		           function
			   alpha omega))
	    (labels ((scan-over (element)
		       (if (arrayp element)
			   (aops:each #'scan-over element)
			   (funcall function
				    (if alpha-unitary? (if (vectorp alpha)
							   (aref alpha 0)
							   alpha)
					(if (vectorp omega)
					    (aref omega 0)
					    omega))
				    element))))
	      (aops:each #'scan-over (if alpha-unitary? omega alpha)))))))

(defun array-match (alpha omega)
  (let ((singleton-alpha (is-singleton alpha))
	(singleton-omega (is-singleton omega)))
    (if (or singleton-alpha singleton-omega
	    (loop for dimension in (funcall (lambda (a o) (mapcar #'= a o))
					    (dims alpha)
					    (dims omega))
	       always dimension))
	(if singleton-alpha
	    (if singleton-omega
		(list alpha omega)
		(list (scale-array alpha omega)
		      omega))
	    (if singleton-omega
		(list alpha (scale-array omega alpha))
		(list alpha omega))))))

(defun array-depth (array &optional layer)
  (let ((layer (if layer layer 1)))
    (aops:each (lambda (item)
		 (if (arrayp item)
		     (setq layer (array-depth item (1+ layer)))))
	       array)
    layer))

(defun array-to-list (array)
  "Convert array to list."
  (let* ((dimensions (dims array))
         (depth (1- (length dimensions)))
         (indices (make-list (1+ depth) :initial-element 0)))
    (labels ((recurse (n)
               (loop for j below (nth n dimensions)
		  do (setf (nth n indices) j)
		  collect (if (= n depth)
			      (apply #'aref array indices)
			      (recurse (1+ n))))))
      (recurse 0))))

(defun multidim-slice (array dimensions &key (inverse nil) (fill-with 0))
  (if (= 1 (length dimensions))
      (apply #'aops:stack
	     (append (list 0 (aops:partition array (if inverse (first dimensions)
						       0)
					     (if inverse
						 (first (dims array))
						 (if (< (first (dims array))
							(first dimensions))
						     (first (dims array))
						     (first dimensions)))))
		     (if (and (not inverse)
			      (< (first (dims array))
				 (first dimensions)))
			 (list (make-array (list (- (first dimensions)
						    (first (dims array))))
					   :initial-element fill-with)))))
      (aops:combine (apply #'aops:stack
			   (append (list 0 (aops:each (lambda (a)
							(multidim-slice a (rest dimensions)
									:inverse
									inverse
									:fill-with fill-with))
						      (subseq (aops:split array 1)
							      (if inverse (first dimensions)
								  0)
							      (if inverse
								  (first (dims array))
								  (if (< (first (dims array))
									 (first dimensions))
								      (first (dims array))
								      (first dimensions))))))
				   (if (and (not inverse)
					    (< (first (dims array))
					       (first dimensions)))
				       (list (make-array (list (- (first dimensions)
								  (first (dims array))))
							 :initial-contents
							 (loop for index from 1 to (- (first dimensions)
										      (first (dims array)))
							    collect (make-array (rest dimensions)
										:initial-element fill-with))))))))))

(defun scan-back (function input &optional output)
  (if (not input)
      output (if (not output)
		 (scan-back function (cddr input)
			    (funcall function (second input)
				     (first input)))
		 (scan-back function (rest input)
			    (funcall function (first input)
				     output)))))

(defun make-back-scanner (function)
  (lambda (sub-array)
    (let ((args (list (aref sub-array 0))))
      (loop for index from 1 to (1- (length sub-array))
	 do (setf args (cons (aref sub-array index)
			     args)
		  (aref sub-array index)
		  (scan-back function args)))
      sub-array)))

(defun apply-marginal (function array axis default-axis)
  (let* ((new-array (copy-array array))
	 (a-rank (rank array))
	 (axis (if axis axis default-axis)))
    (if (> axis (1- a-rank))
	(error "Invalid axis.")
	(progn (if (not (= axis (1- a-rank)))
		   (setq new-array (aops:permute (rot-left (- a-rank 1 axis)
							   (alexandria:iota a-rank))
						 new-array)))
	       (aops:margin (lambda (sub-array) (funcall function sub-array))
			    new-array (1- a-rank))
	       (if (not (= axis (1- a-rank)))
		   (aops:permute (rot-right (- a-rank 1 axis)
					    (alexandria:iota a-rank))
				 new-array)
		   new-array)))))

(defun expand-array (degrees array axis default-axis &key (omit-zeroes nil))
  (let* ((new-array (copy-array array))
	 (a-rank (rank array))
	 (axis (if axis axis default-axis))
	 (singleton-array (loop for dim in (dims array) always (= 1 dim))))
    (if (and singleton-array (< 1 a-rank))
    	(setq array (make-array (list 1) :displaced-to array)))
    (if (> axis (1- a-rank))
	(error "Invalid axis.")
	(progn (if (not (= axis (1- a-rank)))
		   (setq new-array (aops:permute (rot-left (- a-rank 1 axis)
							   (alexandria:iota a-rank))
						 new-array)))
	       (let ((array-segments (aops:split new-array 1))
		     (segment-index 0))
		 (let* ((expanded (loop for degree in degrees
				     append (cond ((< 0 degree)
						   (loop for items from 1 to degree
						      collect (aref array-segments segment-index)))
						  ((and (= 0 degree)
							(not omit-zeroes))
						   (list (if (arrayp (aref array-segments 0))
							     (make-array (dims (aref array-segments 0))
									 :initial-element 0)
							     0)))
						  ((> 0 degree)
						   (loop for items from -1 downto degree
						      collect (if (arrayp (aref array-segments 0))
								  (make-array (dims (aref array-segments 0))
									      :initial-element 0)
								  0))))
				     do (if (not singleton-array)
					    (incf segment-index 1))))
			(output (aops:combine (make-array (length expanded) :initial-contents expanded))))
		   (if (not (= axis (1- a-rank)))
		       (aops:permute (rot-right (- a-rank 1 axis)
						(alexandria:iota a-rank))
				     output)
		       output)))))))

(defun enlist (vector)
  (if (arrayp vector)
      (setq vector (aops:flatten vector)))
  (if (and (vectorp vector)
	   (loop for element from 0 to (1- (length vector))
	      always (not (arrayp (aref vector element)))))
      vector
      (let ((current-segment nil)
	    (segments nil))
	(dotimes (index (length vector))
	  (let ((element (aref vector index)))
	    (if (arrayp element)
		(if (not (= 0 (array-total-size element)))
		    ;; skip empty vectors
		    (setq segments (cons (enlist element)
					 (if current-segment
					     (cons (make-array (list (length current-segment))
							       :initial-contents (reverse current-segment))
						   segments)
					     segments))
			  current-segment nil))
		(setq current-segment (cons element current-segment)))))
	(if current-segment (setq segments (cons (make-array (list (length current-segment))
							     :initial-contents (reverse current-segment))
						 segments)))
	(apply #'aops:stack (cons 0 (reverse segments))))))

(defun array-inner-product (operand1 operand2 function1 function2)
  (aops:each (lambda (sub-vector)
	       (if (vectorp sub-vector)
		   (reduce function2 sub-vector)
		   (funcall function2 sub-vector)))
	     (aops:outer (lambda (arg1 arg2)
			   (if (or (arrayp arg1)
				   (arrayp arg2))
			       (apply-scalar-function function1 arg1 arg2)
			       (funcall function1 arg1 arg2)))
			 (aops:split (aops:permute (alexandria:iota (rank operand1))
						   operand1)
				     1)
			 (aops:split (aops:permute (reverse (alexandria:iota (rank operand2)))
						   operand2)
				     1))))

(vex-spec
 apex
 (environment :count-from 1
	      :atomic-vector
	      (concatenate 'string "!\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`"
			   "abcdefghijklmnopqrstuvwxyz{|}~¥€⇄∧∼≬⋆⋸⌸⌺⌼⌾⍁¡⍣⍅⎕⍞⌹⍆⍤⍇⍈⍊⊤λ⍍⍏£⊥⍶⌶⍐⍑χ≢⍖⍗"
			   "⍘⍚⍛⌈⍜⍢∪⍨⍕⍎⍬⍪∣│┤⍟∆∇→╣║╗╝←⌊┐└┴┬├─┼↑↓╔╚╩╦╠═╬≡⍸⍷∵⌷⍂⌻⊢⊣◊┘┌█▄▌▐▀"
			   "⍺⍹⊂⊃⍝⍲⍴⍱⌽⊖○∨⍳⍉∈∩⌿⍀≥≤≠×÷⍙∘⍵⍫⍋⍒¯¨"))
 (operators / (right (lambda (axes functions operand)
		       (let ((new-array (copy-array operand)))
			 (if (= 1 (rank operand))
			     (reduce (first (last (first functions)))
				     operand)
			     (aops:margin (lambda (sub-array) (reduce (first (last (first functions)))
								      sub-array))
				      new-array (if axes (1- (aref (first axes) 0))
						    (1- (rank operand))))))))
  	    ⌿ (right (lambda (axes functions operand)
  		       (let ((new-array (copy-array operand)))
			 (if (= 1 (rank operand))
			     (reduce (first (last (first functions)))
				     operand)
			     (aops:margin (lambda (sub-array) (reduce (first (last (first functions)))
								      sub-array))
					  new-array (if axes (1- (aref (first axes) 0))
							0))))))
	   \\ (right (lambda (axes functions operand)
  	   	       (apply-marginal (make-back-scanner (first (last (first functions))))
	   			       operand (if axes (1- (aref (first axes) 0)))
	   			       (1- (rank operand)))))
	    ⍀ (right (lambda (axes functions operand)
	   	       (apply-marginal (make-back-scanner (first (last (first functions))))
	   			       operand (if axes (1- (aref (first axes) 0)))
	   			       0)))
  	   \. (center (lambda (axes functions operand right-operand)
			(declare (ignore axes))
			(if (eq :outer-product-designator (second functions))
			    (aops:outer (first (last (first functions)))
					operand right-operand)
			    (if (and (vectorp operand)
				     (vectorp right-operand))
				;; NOTE: this is a hack and has problems,
				;; how to better control for the type of argument?
				(reduce (first (last (second functions)))
					(aops:each (first (last (first functions)))
						   right-operand operand))
				(array-inner-product operand right-operand
						     (first (last (first functions)))
						     (first (last (second functions))))))))
           ;; ¨ must be expressed as #\diaeresis to be correctly processed
  #\diaeresis (right (macro (lambda (meta axes functions operand &optional right-operand)
			      (declare (ignore meta axes))
			      (let ((placeholder nil))
				(if right-operand
				    (setq placeholder operand
					  operand right-operand
					  right-operand placeholder))
				`(let ((new-array (alexandria:copy-array ,operand)))
				   (if ,right-operand
				       (apply-scalar-function ,(first (last (first functions)))
							      ,right-operand
							      (make-array (dims ,right-operand)
									  :initial-element (aref new-array 0)))
				       (aops:each ,(cadar functions) new-array)))))))
            ⍨ (right (macro (lambda (meta axes functions operand &optional right-operand)
			      (funcall (first (last (first functions)))
				       meta axes (if right-operand right-operand operand)
				       operand))))
	    ∘ (center (macro (lambda (meta axes functions operand &optional right-operand)
			       (declare (ignore meta axes))
			       (if (and (first functions)
					(second functions))
				   (if right-operand
				       `(apply-scalar-function ,(third (second functions))
							       ,operand (aops:each ,(second (first functions))
										   ,right-operand))
				       `(aops:each ,(cadadr functions)
						   (aops:each ,(cadar functions)
							      ,operand))))))))
 (functions ← (dyadic (args :sym :any set))
	    ⊣ (ambivalent (args :any (lambda (omega) (make-array (list 0))))
			  (args :any :any (lambda (alpha omega) alpha)))
	    ⊢ (ambivalent (args :any (lambda (omega) omega))
			  (args :any :any (lambda (alpha omega) omega)))
	    + (ambivalent :asymmetric-scalar (lambda (omega) (if (complexp omega)
								 (complex (realpart omega)
									  (- (imagpart omega)))
								 omega))
			  +)
    	    - (ambivalent :symmetric-scalar -)
     	    × (ambivalent :asymmetric-scalar signum *)
     	    ÷ (ambivalent :symmetric-scalar /)
     	    ⋆ (ambivalent :asymmetric-scalar exp expt)
     	    * (ambivalent :asymmetric-scalar exp expt)
     	    ⍟ (ambivalent :symmetric-scalar log)
     	   \| (ambivalent :asymmetric-scalar abs (lambda (alpha omega) (mod omega alpha)))
     	    ! (ambivalent :asymmetric-scalar sprfact (lambda (alpha omega)
     						       (if (= omega alpha)
     							   1 (if (< omega alpha)
     								 0 (/ (sprfact omega)
     								      (* (sprfact alpha)
     									 (sprfact (- omega alpha))))))))
     	    ⌈ (ambivalent :asymmetric-scalar ceiling max)
     	    ⌊ (ambivalent :asymmetric-scalar floor min)
	    ? (ambivalent (args :scalar (lambda (omega) (+ (of-environment *vex-idiom* :count-from)
							   (random omega))))
     			  (args :one :one (lambda (alpha omega)
     					    (make-array (list alpha)
     							:initial-contents
							(loop for i from 0 to (1- alpha)
							   collect (+ (of-environment *vex-idiom* :count-from)
								      (random omega)))))))
     	    ○ (ambivalent (args :scalar (lambda (omega) (* pi omega)))
     			  (args :one :any (lambda (alpha omega)
     					    (let ((fn (vector (lambda (input) (* input (exp #C(0 1))))
							      (lambda (input) (* input #C(0 1)))
							      (lambda (input) (if (complexp input)
										  (complex (realpart input)
											   (- (imagpart input)))
										  input))
							      (lambda (input) input)
     							      (lambda (input) (expt (- -1 (* 2 input))
     										    1/2))
     							      #'atanh #'acosh #'asinh
     							      (lambda (input) (* (expt (/ (1+ input) (1- input))
     										       1/2)
     										 (1+ input)))
     							      #'atan #'acos #'asin
     							      (lambda (input) (expt (- 1 (* 2 input))
     										    1/2))
     							      #'sin #'cos #'tan
     							      (lambda (input) (expt (1+ (* 2 input))
     										    1/2))
     							      #'sinh #'cosh #'tanh
     							      (lambda (input) (expt (- -1 (* 2 input))
     										    1/2))
     							      #'realpart #'abs #'imagpart #'phase)))
     					      ;; the twelfth element of the vector corresponds to
     					      ;; index 0, hence an offset of 12 from the vector's first element
     					      (funcall (aref fn (+ 12 alpha))
     						       omega)))))
	   \~ (monadic (args :scalar (boolean-op (lambda (omega)
						   (cond ((= 0 omega) t)
							 ((= 1 omega) nil)
							 (t (error
							     "Domain error: arguments to ~ must be 1 or 0.")))))))
     	    < (dyadic (args :scalar (boolean-op <)))
     	    ≤ (dyadic (args :scalar (boolean-op <=)))
     	    = (dyadic (args :scalar (boolean-op =)))
     	    ≥ (dyadic (args :scalar (boolean-op >=)))
     	    > (dyadic (args :scalar (boolean-op >)))
     	    ≠ (dyadic (args :scalar (boolean-op /=)))
	    ≡ (ambivalent (args :any array-depth)
			  (args :any :any (boolean-op equalp)))
	    ≢ (ambivalent (args :any (lambda (omega) (first (dims omega))))
			  ;; TODO: equalp is not exactly right for this function
     	    		  (args :any :any (boolean-op (lambda (alpha omega) (not (equalp alpha omega))))))
	    ^ (dyadic (args :scalar lcm))
	    ∧ (dyadic (args :scalar lcm))
	    ⍲ (dyadic (args :scalar (boolean-op (lambda (alpha omega) (not (and (= alpha 1) (= omega 1)))))))
	    ⍱ (dyadic (args :scalar gcd))
     	    ∨ (dyadic (args :scalar (boolean-op (lambda (alpha omega) (not (and (= alpha 0) (= omega 0)))))))
	    ⍳ (ambivalent (args :one (lambda (omega)
     				       (make-array (list omega)
     						   :initial-contents
						   (mapcar (lambda (i)
							     (+ i (of-environment *vex-idiom* :count-from)))
							   (alexandria:iota omega)))))
     			  (args :any :any index-of))
     	    ⍴ (ambivalent (args :any dims)
     			  (args :any :any (lambda (alpha omega)
					    (reshape-array-fitting omega (array-to-list alpha)))))
	    ∊ (ambivalent (args :any enlist)
			  (args :any :any (lambda (alpha omega)
					    (let ((output (alexandria:copy-array alpha)))
					      (dotimes (index (array-total-size output))
						(let ((found nil))
						  (aops:each (lambda (input)
							       (if (= input (row-major-aref output index))
								   (setq found t)))
							     omega)
						  (setf (row-major-aref output index)
							(if found 1 0))))
					      output))))
	    ↑ (ambivalent (args :any (lambda (omega)
     				       (if (not (arrayp omega))
     					   omega (row-major-aref omega 0))))
     			  (args :any :any :axes
				(lambda (alpha omega &optional axes)
				  (multidim-slice omega (if axes (loop for axis from 0 to (1- (rank omega))
								    collect (if (= axis (1- (aref (first axes) 0)))
										(aref alpha 0)
										(nth axis (dims omega))))
							    (array-to-list alpha))
						  :fill-with 0))))
	    ↓ (ambivalent (args :any :axes (lambda (omega &optional axes)
					     ;; NOTE: check this against another implementation
					     (aops:split omega (if axes (aref (first axes) 0)
								   (1- (rank omega))))))
			  (args :any :any :axes
				(lambda (alpha omega &optional axes)
				  (multidim-slice omega (if axes (loop for axis from 0 to (1- (rank omega))
								    collect (if (= axis (1- (aref (first axes) 0)))
										(aref alpha 0)
										0))
							    (array-to-list alpha))
						  :inverse t))))
	    ⌷ (dyadic (args :any :any (lambda (alpha omega)
					(apply #'aref (cons omega (array-to-list alpha))))))
	   \, (ambivalent (args :any (lambda (omega)
     				       (if (vectorp omega)
     					   omega (make-array (list (array-total-size omega))
     							     :displaced-to omega))))
     			  (args :any :any :axes
				(lambda (alpha omega &optional axes)
				  (if (and (not axes)
					   (vectorp alpha)
					   (vectorp omega))
				      (concatenate 'vector alpha omega)
				      (aops:stack (if axes (1- (aref (first axes) 0))
						      1)
						  alpha omega)))))
     	    ⍪ (ambivalent (args :any (lambda (omega) (if (not (second (dims omega)))
							 (make-array (list (length omega) 1)
								     :initial-contents
								     (loop for i from 0 to (1- (length omega))
									collect (list (aref omega i))))
							 omega)))
			  (args :any :any :axes
				(lambda (alpha omega &optional axes)
				  (if (and (not axes)
					   (vectorp alpha)
					   (vectorp omega))
				      (if (not (= (length alpha)
						  (length omega)))
					  (error "Vectors must be of same length.")
					  (make-array (list 2 (length alpha))
						      :initial-contents (list (array-to-list alpha)
									      (array-to-list omega))))
				      (aops:stack (if axes (1- (aref (first axes) 0))
						      0)
						  alpha omega)))))
	    / (dyadic (args :any :any :axes
			    (lambda (alpha omega &optional axes)
			      (expand-array (array-to-list alpha)
					    omega (if axes (- (rank omega)
							      (- (aref (first axes) 0)
								 (1- (of-environment *vex-idiom* :count-from)))))
					    0 :omit-zeroes t))))
	    ⌿ (dyadic (args :any :any :axes
			    (lambda (alpha omega &optional axes)
			      (expand-array (array-to-list alpha)
					    omega (if axes (- (rank omega)
							      (- (aref (first axes) 0)
								 (1- (of-environment *vex-idiom* :count-from)))))
					    (1- (rank omega))
					    :omit-zeroes t))))
	   \\ (dyadic (args :any :any :axes
			    (lambda (alpha omega &optional axes)
			      (expand-array (array-to-list alpha) ;[1] 1 [2] 0 / [0] 1 [1] 0
					    omega (if axes (- (rank omega)
							      (- (aref (first axes) 0)
								 (1- (of-environment *vex-idiom* :count-from)))))
					    0))))
	    ⍀ (dyadic (args :any :any :axes
			    (lambda (alpha omega &optional axes)
			      (expand-array (array-to-list alpha)
					    omega (if axes (- (rank omega)
							      (- (aref (first axes) 0)
								 (1- (of-environment *vex-idiom* :count-from)))))
					    (1- (rank omega))))))
	    ⍷ (dyadic (args :any :any find-array))
	    ⊂ (ambivalent (args :any (lambda (omega)
				       (if (loop for dim in (dims omega) always (= 1 dim))
					   omega (make-array (list 1) :initial-element omega))))
			  (args :any :any (lambda (alpha omega)
					    (if (/= (length alpha) (length omega))
						(error "Length mismatch.")
						(let ((output nil)
						      (accumulator nil)
						      (partition-index 0))
						  (dotimes (index (length alpha))
						    (if (and (< 0 index)
							     (< partition-index (aref alpha index)))
							(progn (setq output
								     (cons (make-array (list (length accumulator))
										       :initial-contents
										       (reverse accumulator))
									   output))
							       (setq accumulator nil)))
						    (setq partition-index (aref alpha index))
						    (if (< 0 (aref alpha index))
							(setq accumulator (cons (aref omega index)
										accumulator))))
						  (if accumulator (setq output
									(cons (make-array
									       (list (length accumulator))
									       :initial-contents
									       (reverse accumulator))
									      output)))
						  (make-array (list (length output))
							      :initial-contents (reverse output)))))))
	    ⊃ (ambivalent (args :any (lambda (omega)
				       ;; currently works for vectors only
				       (let ((output (make-array
						      (list (length omega)
							    (apply #'max (array-to-list (aops:each #'length
												   omega)))))))
					 (dotimes (index (length omega))
					   (dotimes (sub-index (length (aref omega index)))
					     (setf (aref output index sub-index)
						   (aref (aref omega index) sub-index))))
					 output)))
			  (args :one :any (lambda (alpha omega)
					    (apply #'aref (cons omega (array-to-list (aref alpha 0)))))))
	    ∪ (ambivalent (args :any (lambda (omega)
				       (if (not (vectorp omega))
					   (error "Argument must be a vector.")
					   (let ((uniques nil))
					     (dotimes (index (length omega))
					       (if (not (find (aref omega index)
							      uniques))
						   (setq uniques (cons (aref omega index)
								       uniques))))
					     (make-array (list (length uniques))
							 :initial-contents (reverse uniques))))))
			  (args :any :any (lambda (alpha omega)
					    (if (or (not (vectorp alpha))
						    (not (vectorp omega)))
						(error "Arguments must be vectors.")
						(let ((uniques nil))
						  (dotimes (index (length omega))
						    (if (not (find (aref omega index)
								   alpha))
							(setq uniques (cons (aref omega index)
									    uniques))))
						  (concatenate 'vector alpha
							       (make-array (list (length uniques))
									   :initial-contents
									   (reverse uniques))))))))
	    ∩ (dyadic (args :any :any (lambda (alpha omega)
					(if (or (not (vectorp alpha))
						(not (vectorp omega)))
					    (error "Arguments must be vectors.")
					    (let ((matches nil))
					      (dotimes (index (length alpha))
						(if (find (aref alpha index)
							  omega)
						    (setq matches (cons (aref alpha index)
									matches))))
					      (make-array (list (length matches))
							  :initial-contents (reverse matches)))))))
	    ⌽ (ambivalent (args :any :axes (lambda (omega &optional axes)
					     (apply-marginal (make-rotator)
							     omega (if axes (1- (aref (first axes) 0)))
							     (1- (rank omega)))))
     	 	          (args :one :any :axes
				(lambda (alpha omega &optional axes)
				  (apply-marginal (make-rotator alpha)
						  omega (if axes (1- (aref (first axes) 0)))
						  (1- (rank omega))))))
     	    ⊖ (ambivalent (args :any :axes (lambda (omega &optional axes)
					     (apply-marginal (make-rotator)
							     omega (if axes (1- (aref (first axes) 0)))
							     0)))
     			  (args :one :any :axes
				(lambda (alpha omega &optional axes)
				  (apply-marginal (make-rotator alpha)
						  omega (if axes (1- (aref (first axes) 0)))
						  0))))
	    ⍉ (ambivalent (args :any (lambda (omega)
				       (aops:permute (reverse (alexandria:iota (rank omega)))
						     omega)))
			  (args :any :any (lambda (alpha omega)
					    (aops:permute (mapcar (lambda (i)
								    (- i (of-environment *vex-idiom*
											 :count-from)))
								  (array-to-list alpha))
							  omega))))
            ;; TODO: dyadic functions of ⍒⍋ only support vectors as a right argument
	    ⍋ (ambivalent (args :any (lambda (omega) (grade omega (alpha-compare #'<=))))
			  (args :any :any (lambda (alpha omega) (grade (index-of alpha omega)
								       (alpha-compare #'<)))))
	    ⍒ (ambivalent (args :any (lambda (omega) (grade omega (alpha-compare #'>=))))
			  (args :any :any (lambda (alpha omega) (grade (index-of alpha omega)
								       (alpha-compare #'>)))))
	    ;; TODO: inversion does not yet work for non-square matrices
	    ⌹ (ambivalent (args :any (lambda (omega)
				       (if (and (= 1 (rank omega))
						(= 1 (length omega)))
					   (/ (aref omega 0))
					   (invert-matrix omega))))
			  (args :any :any (lambda (alpha omega) (array-inner-product (invert-matrix omega)
										     alpha #'* #'+))))
	    ⊤ (dyadic (args :any :any (lambda (alpha omega)
					(flet ((rebase (bases number)
						 (let ((operand number)
						       (last-base 1)
						       (base 1)
						       (component 1)
						       (element nil))
						   (loop for index from (1- (length bases)) downto 0
						      do (setq last-base base
							       base (* base (aref bases index))
							       component (if (= 0 base)
									     operand
									     (* base
										(nth-value 1 (floor (/ operand
												       base)))))
							       operand (- operand component)
							       element (/ component last-base))
						      collect element))))
					  (if (= 1 (length omega))
					      (let ((result (rebase alpha (aref omega 0))))
						(make-array (list (length result))
							    :initial-contents (reverse result)))
					      (aops:permute (list 1 0)
							    (make-array (list (length omega) (length alpha))
									:initial-contents
									(mapcar (lambda (item)
										  (reverse (rebase alpha item)))
										(array-to-list omega)))))))))
	    ⊥ (dyadic (args :any :any (lambda (alpha omega)
					(flet ((rebase (bases numerators)
						 (let ((result 0)
						       (base 1))
						   (loop for index from (1- (length numerators)) downto 0
						      do (incf result (* base (aref numerators index)))
							(setf base (* base (aref bases index))))
						   result)))
					  (let ((bases (if (= 1 (length alpha))
							   (make-array (list (first (dims omega)))
								       :initial-element (aref alpha 0))
							   (if (not (= (length alpha)
								       (let ((d-o (dims omega)))
									 (if (= 1 (length d-o))
									     (first d-o)
									     (second d-o)))))
							       (error "Base/element length mismatch.")
							       alpha))))
					    (if (= 1 (rank omega))
						(rebase bases omega)
						(aops:margin (lambda (sub-array) (rebase bases sub-array))
							     omega 0)))))))
	      ⍎ (monadic (args :any (lambda (omega) (eval (vex-program *vex-idiom* nil omega)))))
	      ∘ (symbolic :outer-product-designator)))

(defun process-reverse (function input &optional output)
  (if input
      (process-reverse function (rest input)
		       (cons (funcall function (first input))
			     output))
      output))

(defun =vex-operation (idiom meta at-start?)
  "Parse an operation belonging to a Vex expression, returning the operation string and tokens extracted along with the remainder of the expression string."
  (labels ((?blank-character ()
	     (?satisfies (lambda (c) (member c (list #\  #\tab)))))
	   (?token-character ()
	     (%or (?satisfies 'alphanumericp)
		  ;; the ¯ character must be expressed as #\macron to be correctly processed
		  ;; the ̄ (combining_macron) character can be denoted normally, however
		  (?satisfies (lambda (c) (member c (list #\macron #\̄ #\. #\⍺ #\⍵ #\⍬))))))
	   (=string (&rest delimiters)
	     (let ((lastc nil)
		   (delimiter nil))
	       (=destructure (_ content)
		   (=list (?satisfies (lambda (c) (if (member c delimiters)
						      (setq delimiter c))))
			  ;; note: nested quotes must be checked backwards; to determine whether a delimiter
			  ;; indicates the end of the quote, look at previous character to see whether it is a
			  ;; delimiter, then check whether the current character is an escape character #\\
			  (=subseq (%any (?satisfies (lambda (c) (if (or (not lastc)
									 (not (char= lastc delimiter))
									 (char= c #\\))
								     (setq lastc c)))))))
		 (format nil "~a~a" delimiter content))))
	   (=vex-opglyphs ()
	     (let ((ops nil))
	       (flet ((glyph-finder (glyph)
			(cond ((and (not (getf ops :op))
				    (gethash glyph (idiom-operators idiom)))
			       (if (and (not ops)
					(not (getf ops :fn))
					(member glyph (getf (idiom-opindex idiom) :right)))
				   (setf (getf ops :op) glyph)
				   (if (and (getf ops :fn)
					    (member glyph (getf (idiom-opindex idiom) :center)))
				       (setf (getf ops :op) glyph))))
			      ((gethash glyph (idiom-functions idiom))
			       (if (not (getf ops :fn))
				   (setf (getf ops :fn) glyph)
				   (if (and (getf ops :op)
					    (not (getf ops :afn)))
				       (setf (getf ops :afn) glyph))))
			      (t nil))))
		 (=destructure (_ glyph-group)
		     (=list (%any (?blank-character))
			    (=subseq (%any (?satisfies #'glyph-finder))))
		   (declare (ignore glyph-group))
		   ;; if only an operator was found, check whether the glyph is a member of the
		   ;; overloaded lexicon. If so, it will be reassigned as a function glyph, if not an
		   ;; error will occur
		   (if (and (getf ops :op)
			    (not (getf ops :fn)))
		       (if (member (getf ops :op)
				   (idiom-overloaded-lexicon idiom))
			   (setf (getf ops :fn) (getf ops :op)
				 (getf ops :op) nil)))
		   ops))))
	   (=vex-tokens (&optional first-token?) ;; recursive parser for tokens and closures
	     (=destructure (_ axis _ token _ last) ;;next last)
		 (=list (%any (?blank-character))
			(%maybe (=vex-closure "[]" #'handle-axes))
			(%any (?blank-character))
			(if (and first-token? at-start?)
			    ;; only process a function as a value if it's the first token in the expression
			    (%or (=vex-closure "{}" #'handle-function-as-data)
				 (=subseq (%some (?token-character)))
				 (=string #\' #\")
				 (=vex-closure "()"))
			    (%or (=subseq (%some (?token-character)))
				 (=string #\' #\") (=vex-closure "()")))
			(%any (?blank-character))
			(=subseq (%any (?satisfies 'characterp))))
	       (let ((token (if (not axis)
				token (list :axis axis token)))
		     (next (parse last (=vex-tokens))))
		 (if (or (not (stringp token))
			 (not (member (format-value (reverse token))
				      (gethash :functions meta))))
		     (if next (list (cons token (first next))
				    (second next))
			 (list (list token) last))))))
	   (=vex-closure (boundary-chars &optional transform-by)
	     (let ((balance 1))
	       (=destructure (_ enclosed _)
		   (=list (?eq (aref boundary-chars 1))
			  (=transform (=subseq (%some (?satisfies (lambda (char)
								    (if (char= char (aref boundary-chars 1))
									(incf balance 1))
								    (if (char= char (aref boundary-chars 0))
									(incf balance -1))
								    (< 0 balance)))))
				      (if transform-by transform-by
					  (lambda (string-content)
					    (vex-expression idiom meta string-content))))
			  (?eq (aref boundary-chars 0)))
		 enclosed)))
	   (=vex-axes () ;; handle axes, separated by semicolons
	     (=destructure (element _ next last)
		 (=list (=subseq (%some (?satisfies (lambda (c) (not (char= c #\;))))))
			(?eq #\;)
			(%maybe '=vex-axes-parser)
			(=subseq (%any (?satisfies (lambda (c) (not (char= c #\;)))))))
	       (if next (cons element next)
		   (list element last))))
	   (handle-axes (input-string)
	     (let ((axes (parse input-string (=vex-axes))))
	       ;; reverse the order of axes, since we're parsing backwards
	       (process-reverse (lambda (string-content) (vex-expression idiom meta string-content))
				(if axes axes (list input-string)))))
	   (handle-function (input-string)
	     (let ((formatted-function (format-function (vex-expression idiom meta input-string))))
	       (lambda (meta axes omega &optional alpha)
		 (declare (ignorable meta axes))
		 `(funcall ,formatted-function
			   ,@(if alpha (list (macroexpand alpha)))
			   ,(macroexpand omega)))))
	   (handle-function-as-data (input-string)
	     (format-function (vex-expression idiom meta input-string))))
    
    (setf (fdefinition '=vex-tokens-parser) (=vex-tokens)
	  (fdefinition '=vex-axes-parser) (=vex-axes))
    
    (=destructure (_ hd tl last)
	(if at-start? ;; handle the initial value in the expression at the start
	    (=list (%any (?blank-character))
		   (%maybe (=vex-tokens t))
		   (=subseq (%any (?satisfies 'characterp)))
		   (=subseq (%any (?satisfies 'characterp))))
	    ;; then handle each operation (function and sometimes operator) and the following tokens
	    (=list (%any (?blank-character))
		   (=list (%maybe (=vex-closure "[]" #'handle-axes))
		   	  (%or (=vex-closure "{}" #'handle-function)
			       (=subseq (%some (?token-character)))
			       (=vex-opglyphs)))
		   (%maybe (=vex-tokens))
		   (=subseq (%any (?satisfies 'characterp)))))
      (if (and (not at-start?)
      	       (stringp (second hd)))
      	  (let ((function-string (second hd)))
	    (setq hd (list (first hd)
			   (function (lambda (meta axes omega &optional alpha)
			     (declare (ignorable meta axes))
			     (if alpha
				 `(aref (apply-scalar-function ,(format-value (reverse function-string))
							       ,(macroexpand alpha)
							       ,(macroexpand omega))
					0)
				 `(aref (aops:each ,(format-value (reverse function-string))
						   ,(macroexpand omega))
					0))))))))
      ;; if the head of the operation is a string (thus a symbol-referenced function),
      ;; format it and compose the operation spec accordingly
      (if at-start? (setq tl hd hd nil))
      (list hd (if tl
		   (list (process-reverse (lambda (value) (cond ((stringp value)
								 (format-value (reverse value)))
								((and (listp value)
								      (eq :axis (first value)))
								 `(apply #'aref
									 (cons ,(if (stringp (third value))
										    (format-value
										     (reverse (third value)))
										    (third value))
									       (mapcar (lambda (i) (1- (aref i 0)))
										       (list ,@(second value))))))
								(t value)))
					  (first tl))
			 (second tl))
		   (list nil last))))))

(defun vex-expression (idiom meta string &optional precedent)
  "Convert an expression into Lisp code, tranforming the text through the parser and invoking the corresponding spec-defined functions accordingly."
  (if (= 0 (length string))
      precedent
      (let* ((next-operation (parse string (=vex-operation idiom meta (not precedent))))
	     (operation (cadar next-operation))
	     (operation-axes (caar next-operation))
	     (value-results (second next-operation))
	     (operator (if (not (or (functionp operation)
				    (eql 'lambda (first operation))))
			   (gethash (getf operation :op)
				    (idiom-operators idiom))))
	     (function (if (or (functionp operation)
			       (eql 'lambda (first operation)))
			   (list operation)
			   (gethash (getf operation :fn)
				    (idiom-functions idiom))))
	     (alpha-function (if (not (or (functionp operation)
					  (eql 'lambda (first operation))))
				 (gethash (getf operation :afn)
					  (idiom-functions idiom)))))
	(vex-expression idiom meta (second value-results)
			(apply (cond (operator operator)
				     (function (first function))
				     (t (lambda (&rest items) (third items))))
			       (append (list meta operation-axes)
				       (if operator
					   (list (cons function (if alpha-function (list alpha-function)))))
				       (if (first value-results)
					   (list (format-array (first value-results))))
				       (if precedent (list precedent))))))))

(defun vex-program (idiom options string &optional meta)
  (let ((meta (if meta meta (make-hash-table :test #'eq))))
    (setf (gethash :functions meta)
	  nil)
    `(progn
       ,@(loop for exp in (cl-ppcre:split "[◊\\r\\n]\\s{0,}" ;; whitespace after diamonds is removed
					  (regex-replace-all (concatenate 'string "^\\s{0,}⍝(.*)[\\r\\n]"
									  "|(?<=[\\r\\n])\\s{0,}⍝(.*)[\\r\\n]"
									  "|(?<=[^\\r\\n])\\s{0,}⍝(.*)(?=[\\r\\n])")
							     string ""))
	    collect (vex-expression idiom meta (reverse exp))))))

(defun index-of (set to-search)
  (if (not (vectorp set))
      (error "Rank error.")
      (let* ((to-find (remove-duplicates set :from-end t))
	     (maximum (+ 1 (length set)))
	     (results (if (stringp to-search)
			  (make-array (list (length to-search)))
			  (alexandria:copy-array to-search))))
	(dotimes (index (array-total-size results))
	  (setf (row-major-aref results index)
		(let ((found (position (row-major-aref to-search index)
				       to-find)))
		  (if found (1+ found)
		      maximum))))
	results)))

(defun alpha-compare (compare-by)
  (lambda (item1 item2)
    (flet ((assign-char-value (char)
	     (let ((vector-pos (position char (of-environment *vex-idiom* :atomic-vector))))
	       (if vector-pos vector-pos (length (of-environment *vex-idiom* :atomic-vector))))))
      (if (numberp item1)
	  (or (characterp item2)
	      (if (= item1 item2)
		  :equal (funcall compare-by item1 item2)))
	  (if (characterp item1)
	      (if (characterp item2)
		  (if (char= item1 item2)
		      :equal (funcall compare-by (assign-char-value item1)
				      (assign-char-value item2)))))))))
  
(defun vector-grade (compare-by vector1 vector2 &optional index)
  (let ((index (if index index 0)))
    (cond ((>= index (length vector1))
	   (not (>= index (length vector2))))
	  ((>= index (length vector2)) nil)
	  (t (let ((compared (funcall compare-by (aref vector1 index)
				      (aref vector2 index))))
	       (if (eq :equal compared)
		   (vector-grade compare-by vector1 vector2 (1+ index))
		   compared))))))

(defun grade (array compare-by)
  (let* ((array (if (= 1 (rank array))
		    array (aops:split array 1)))
	 (vector (make-array (list (length array))))
	 (graded-array (make-array (list (length array))
				   :initial-contents (mapcar #'1+ (alexandria:iota (length array))))))
    (loop for index from 0 to (1- (length vector))
       do (setf (aref vector index)
		(if (and (arrayp (aref array index))
			 (< 1 (rank (aref array index))))
		    (grade (aref array index)
			   compare-by)
		    (aref array index))))
    (stable-sort graded-array (lambda (1st 2nd)
				(let ((val1 (aref vector (1- 1st)))
				      (val2 (aref vector (1- 2nd))))
				  (cond ((not (arrayp val1))
					 (if (arrayp val2)
					     (funcall compare-by val1 (aref val2 0))
					     (let ((output (funcall compare-by val1 val2)))
					       (and output (not (eq :equal output))))))
					((not (arrayp val2))
					 (funcall compare-by (aref val1 0)
						  val2))
					(t (vector-grade compare-by val1 val2))))))
    graded-array))

(defun find-array (target array)
  "Find instances of an array within a larger array."
  (let ((target-head (row-major-aref target 0))
	(target-dims (append (if (< (rank target)
				    (rank array))
				 (loop for index from 0 to (1- (- (rank array)
								  (rank target)))
				    collect 1))
			     (dims target)))
	(output (make-array (dims array) :initial-element 0))
	(match-coords nil)
	(confirmed-matches nil))
    (run-dim array (lambda (element coords)
		     (if (equal element target-head)
			 (setq match-coords (cons coords match-coords)))))
    (loop for match in match-coords
       do (let ((target-index 0)
		(target-matched t)
		(target-displaced (make-array (list (array-total-size target))
					      :displaced-to target)))
	    (run-dim array (lambda (element coords)
			     (if (and (< target-index (length target-displaced))
				      (not (equal element (aref target-displaced target-index))))
				 (setq target-matched nil))
			     (incf target-index 1))
		     nil nil :start-at match :limit target-dims)
	    ;; check the target index in case the elements in the searched array ran out
	    (if (and target-matched (= target-index (length target-displaced)))
		(setq confirmed-matches (cons match confirmed-matches)))))
    (loop for match in confirmed-matches
       do (setf (apply #'aref (cons output match))
		1))
    output))

(defun run-dim (array function &optional dimensions indices &key (start-at nil) (limit nil))
  "Iterate across a range of elements in an array, with an optional starting point and limits."
  (let ((dimensions (if dimensions dimensions (dims array))))
    (loop for elix from (if start-at (nth (length indices)
					  start-at)
			    0)
       to (min (if limit
		   (+ (if start-at (nth (length indices)
					start-at)
			  0)
		      -1 (nth (length indices)
			      limit))
		   (1- (nth (length indices)
			    dimensions)))
	       (1- (nth (length indices)
			dimensions)))
       do (if (< (length indices)
		 (1- (length dimensions)))
	      (run-dim array function dimensions (append indices (list elix))
		       :start-at start-at :limit limit)
	      (funcall function (apply #'aref (cons array (append indices (list elix))))
		       (append indices (list elix)))))))

(defun invert-matrix (in-matrix)
    (let ((dim (array-dimension in-matrix 0))   ;; dimension of matrix
          (det 1)                               ;; determinant of matrix
          (l nil)                               ;; permutation vector
          (m nil)                               ;; permutation vector
          (temp 0)
	  (out-matrix (make-array (dims in-matrix))))

        (if (not (equal dim (array-dimension in-matrix 1)))
            (error "invert-matrix () - matrix not square"))

        ;; (if (not (equal (array-dimensions in-matrix) 
        ;;                 (array-dimensions out-matrix)))
        ;;     (error "invert-matrix () - matrices not of the same size"))

        ;; copy in-matrix to out-matrix if they are not the same
        (when (not (equal in-matrix out-matrix))
            (do ((i 0 (1+ i)))
                ((>= i dim))    
                (do ((j 0 (1+ j)))
                    ((>= j dim)) 
                    (setf (aref out-matrix i j) (aref in-matrix i j)))))

        ;; allocate permutation vectors for l and m, with the 
        ;; same origin as the matrix
        (setf l (make-array `(,dim)))
        (setf m (make-array `(,dim)))

        (do ((k 0 (1+ k))
             (biga 0)
             (recip-biga 0))
            ((>= k dim))

            (setf (aref l k) k)
            (setf (aref m k) k)
            (setf biga (aref out-matrix k k))

            ;; find the biggest element in the submatrix
            (do ((i k (1+ i)))
                ((>= i dim))    
                (do ((j k (1+ j)))
                    ((>= j dim)) 
                    (when (> (abs (aref out-matrix i j)) (abs biga))
                        (setf biga (aref out-matrix i j))
                        (setf (aref l k) i)
                        (setf (aref m k) j))))

            ;; interchange rows
            (if (> (aref l k) k)
                (do ((j 0 (1+ j))
                     (i (aref l k)))
                    ((>= j dim)) 
                    (setf temp (- (aref out-matrix k j)))
                    (setf (aref out-matrix k j) (aref out-matrix i j))
                    (setf (aref out-matrix i j) temp)))

            ;; interchange columns 
            (if (> (aref m k) k)
                (do ((i 0 (1+ i))
                     (j (aref m k)))
                    ((>= i dim)) 
                    (setf temp (- (aref out-matrix i k)))
                    (setf (aref out-matrix i k) (aref out-matrix i j))
                    (setf (aref out-matrix i j) temp)))

            ;; divide column by minus pivot (value of pivot 
            ;; element is in biga)
            (if (equalp biga 0) 
                (return-from invert-matrix 0))
            (setf recip-biga (/ 1 biga))
            (do ((i 0 (1+ i)))
                ((>= i dim)) 
                (if (not (equal i k))
                    (setf (aref out-matrix i k) 
                          (* (aref out-matrix i k) (- recip-biga)))))

            ;; reduce matrix
            (do ((i 0 (1+ i)))
                ((>= i dim)) 
                (when (not (equal i k))
                    (setf temp (aref out-matrix i k))
                    (do ((j 0 (1+ j)))
                        ((>= j dim)) 
                        (if (not (equal j k))
                            (incf (aref out-matrix i j) 
                                  (* temp (aref out-matrix k j)))))))

            ;; divide row by pivot
            (do ((j 0 (1+ j)))
                ((>= j dim)) 
                (if (not (equal j k))
                    (setf (aref out-matrix k j)
                          (* (aref out-matrix k j) recip-biga))))

            (setf det (* det biga)) ;; product of pivots
            (setf (aref out-matrix k k) recip-biga)) ;; k loop

        ;; final row & column interchanges
        (do ((k (1- dim) (1- k)))
            ((< k 0))
            (if (> (aref l k) k)
                (do ((j 0 (1+ j))
                     (i (aref l k)))
                    ((>= j dim))
                    (setf temp (aref out-matrix j k))
                    (setf (aref out-matrix j k) 
                          (- (aref out-matrix j i)))
                    (setf (aref out-matrix j i) temp)))
            (if (> (aref m k) k)
                (do ((i 0 (1+ i))
                     (j (aref m k)))
                    ((>= i dim))
                    (setf temp (aref out-matrix k i))
                    (setf (aref out-matrix k i) 
                          (- (aref out-matrix j i)))
                    (setf (aref out-matrix j i) temp))))
        det ;; return determinant
    out-matrix))
