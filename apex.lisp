;;;; apex.lisp

(in-package #:apex)
 
(defun array-to-list (array)
  "Convert array to list."
  (let* ((dimensions (dims array))
         (depth (1- (length dimensions)))
         (indices (make-list (1+ depth) :initial-element 0)))
    (labels ((recurse (n)
               (loop for j below (nth n dimensions)
		  do (setf (nth n indices) j)
		  collect (if (= n depth)
			      (apply #'aref array indices)
			      (recurse (1+ n))))))
      (recurse 0))))

(vex-spec
 apex
 (environment :count-from 1
	      :atomic-vector
	      (concatenate 'string "!\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`"
			   "abcdefghijklmnopqrstuvwxyz{|}~¥€⇄∧∼≬⋆⋸⌸⌺⌼⌾⍁¡⍣⍅⎕⍞⌹⍆⍤⍇⍈⍊⊤λ⍍⍏£⊥⍶⌶⍐⍑χ≢⍖⍗"
			   "⍘⍚⍛⌈⍜⍢∪⍨⍕⍎⍬⍪∣│┤⍟∆∇→╣║╗╝←⌊┐└┴┬├─┼↑↓╔╚╩╦╠═╬≡⍸⍷∵⌷⍂⌻⊢⊣◊┘┌█▄▌▐▀"
			   "⍺⍹⊂⊃⍝⍲⍴⍱⌽⊖○∨⍳⍉∈∩⌿⍀≥≤≠×÷⍙∘⍵⍫⍋⍒¯¨"))
 (operators (/ (has :title "Reduce")
 	       (right (lambda (axes functions operand)
 			(let ((new-array (copy-array operand)))
 			  (if (= 1 (rank operand))
 			      (make-array (list 1) :initial-element (reduce (first (last (first functions)))
 									    operand))
 			      (aops:margin (lambda (sub-array) (reduce (first (last (first functions)))
 								       sub-array))
 					   new-array (if axes (1- (aref (first axes) 0))
 							 (1- (rank operand))))))))
 	       (tests (is "+/1 2 3 4 5" #(15))
 		      (is "+/3 4⍴⍳12" #(10 26 42))
 		      (is "+/[1]3 4⍴⍳12" #(15 18 21 24))))
  	    (⌿ (has :title "Reduce First")
 	       (right (lambda (axes functions operand)
 			(let ((new-array (copy-array operand)))
 			  (if (= 1 (rank operand))
 			      (make-array (list 1) :initial-element (reduce (first (last (first functions)))
 									    operand))
 			      (aops:margin (lambda (sub-array) (reduce (first (last (first functions)))
 								       sub-array))
 					   new-array (if axes (1- (aref (first axes) 0))
 							 0))))))
 	       (tests (is "+⌿3 4⍴⍳12" #(15 18 21 24))))
 	    (\\ (has :title "Scan")
 		(right (lambda (axes functions operand)
 			 (if (vectorp operand)
 			     (funcall (make-back-scanner (first (last (first functions))))
 				      operand)
 			     (if (arrayp operand)
 				 (apply-marginal (make-back-scanner (first (last (first functions))))
 						 operand (if axes (1- (aref (first axes) 0)))
 						 (1- (rank operand)))))))
 		(tests (is "+\\1 2 3 4 5" #(1 3 6 10 15))
 		       (is "+\\3 4⍴⍳12" #2A((1 3 6 10) (5 11 18 26) (9 19 30 42)))))
 	    (⍀ (has :title "Scan First")
 	       (right (lambda (axes functions operand)
 			(if (vectorp operand)
 			    (funcall (make-back-scanner (first (last (first functions))))
 				     operand)
 			    (if (arrayp operand)
 				(apply-marginal (make-back-scanner (first (last (first functions))))
 						operand (if axes (1- (aref (first axes) 0)))
 						0)))))
 	       (tests (is "+⍀1 2 3 4 5" #(1 3 6 10 15))
 		      (is "+⍀3 4⍴⍳12" #2A((1 2 3 4) (6 8 10 12) (15 18 21 24)))))
 	    (\. (has :title "Inner/Outer Product")
 		(center (lambda (axes functions operand right-operand)
 			  (declare (ignore axes))
 			  (if (eq :outer-product-designator (second functions))
 			      (aops:outer (first (last (first functions)))
 					  operand right-operand)
 			      (if (and (vectorp operand)
 				       (vectorp right-operand))
 				  ;; NOTE: this is a hack and has problems,
 				  ;; how to better control for the type of argument?
 				  (make-array (list 1)
 					      :initial-element
 					      (reduce (first (last (second functions)))
 						      (aops:each (first (last (first functions)))
 								 right-operand operand)))
 				  (array-inner-product operand right-operand
 						       (first (last (first functions)))
 						       (first (last (second functions))))))))
 		(tests (is "2 3 4+.×8 15 21" #(145))
 		       (is "4 5 6∘.+20 30 40 50" #2A((24 34 44 54) (25 35 45 55) (26 36 46 56)))))
 	    (\¨ (has :title "Each")
 		(right (macro (lambda (meta axes functions operand &optional right-operand)
 				(declare (ignore meta axes))
 				(let ((placeholder nil))
 				  (if right-operand (setq placeholder operand
 							  operand right-operand
 							  right-operand placeholder))
 				  `(let ((new-array (alexandria:copy-array ,operand)))
 				     (if ,right-operand
 					 ;; (apply-scalar-function ,(first (last (first functions)))
 					 ;; 			      ,right-operand
 					 ;; 			      (make-array (dims ,right-operand)
 					 ;; 					  :initial-element (aref new-array 0)))
 					 (make-array (dims ,right-operand)
 						     :initial-contents
 						     (loop for index from 0 to (1- (length ,right-operand))
 							collect (funcall ,(first (last (first functions)))
 									 (aref ,right-operand index)
 									 (aref new-array 0))))
 					 (aops:each ,(caar functions) new-array)))))))
 		(tests (is "1 ¯1 ⌽¨⊂1 2 3 4 5" #(#(2 3 4 5 1) #(5 1 2 3 4)))))
 	   (⍨ (has :title "Commute")
 	      (right (macro (lambda (meta axes functions operand &optional right-operand)
 			      (funcall (caar functions)
 				       meta axes (if right-operand right-operand operand)
 				       operand))))
 	      (tests (is "5-⍨10" #(5))))
 	   (∘ (has :title "Composition")
 	      (center (macro (lambda (meta axes functions operand &optional right-operand)
 			       (declare (ignore meta axes))
 			       (if (and (first functions)
 					(second functions))
 				   (if right-operand
 				       `(apply-scalar-function ,(third (second functions))
 							       ,operand (aops:each ,(second (first functions))
 										   ,right-operand))
 				       `(aops:each ,(cadadr functions)
 						   (aops:each ,(cadar functions)
 							      ,operand)))))))))
 (functions (← (has :title "Assign")
	       (dyadic (args :sym :any set)))
	    (⊣ (has :title "Left")
	       (ambivalent (args :any (lambda (omega)
					(declare (ignore omega))
					(make-array (list 0))))
			   (args :any :any (lambda (alpha omega)
					     (declare (ignore omega))
					     alpha))))
	    (⊢ (has :title "Right")
	       (ambivalent (args :any (lambda (omega) omega))
			   (args :any :any (lambda (alpha omega)
					     (declare (ignore alpha))
					     omega))))
	    (+ (has :titles ("Identity" "Add"))
	       (ambivalent :asymmetric-scalar (lambda (omega) (if (complexp omega)
								  (complex (realpart omega)
									   (- (imagpart omega)))
								  omega))
			   +)
	       (tests (is "1+1" #(2))
		      (is "1+1 2 3" #(2 3 4))))
    	    (- (has :titles ("Negate" "Subtract"))
	       (ambivalent :symmetric-scalar -)
	       (tests (is "2-1" #(1))))
     	    (× (has :titles ("Sign" "Multiply"))
	       (ambivalent :asymmetric-scalar signum *)
	       (tests (is "2×3" #(6))
		      (is "4 5×8 9" #(32 45))
		      (is "×20 5 0 -5 5 -9" #(1 1 0 -1 1 -1))))
     	    (÷ (has :titles ("Reciprocal" "Divide"))
	       (ambivalent :symmetric-scalar /)
	       (tests (is "6÷2" #(3))
		      (is "12÷6 3 2" #(2 4 6))
		      (is "÷2 4 8" #(1/2 1/4 1/8))))
     	    (⋆ (has :titles ("Exponential" "Power"))
	       (ambivalent :asymmetric-scalar exp expt))
     	    (* (has :titles ("Exponential" "Power"))
	       (ambivalent :asymmetric-scalar exp expt))
     	    (⍟ (has :titles ("Natural Logarithm" "Logarithm"))
	       (ambivalent :symmetric-scalar log))
     	    (\| (has :titles ("Magnitude" "Residue"))
	    	(ambivalent :asymmetric-scalar abs (lambda (alpha omega) (mod omega alpha))))
     	    (! (has :titles ("Factorial" "Binomial"))
	       (ambivalent :asymmetric-scalar sprfact binomial))
     	    (⌈ (has :titles ("Ceiling" "Maximum"))
	       (ambivalent :asymmetric-scalar ceiling max))
     	    (⌊ (has :titles ("Floor" "Minimum"))
	       (ambivalent :asymmetric-scalar floor min))
	    (? (has :titles ("Random" "Deal"))
	       (ambivalent (args :scalar (lambda (idiom)
					   (lambda (omega)
					     (+ (of-environment idiom :count-from)
						(random omega)))))
	    		   (args :one :one (lambda (idiom alpha omega)
	    				     (make-array (list alpha)
	    						 :initial-contents
	    						 (loop for i from 0 to (1- alpha)
	    						    collect (+ (of-environment idiom :count-from)
	    							       (random omega))))))))
     	    (○ (has :titles ("Pi Times" "Circular"))
	       (ambivalent (args :scalar (lambda (omega) (* pi omega)))
	    		   (args :one :any (lambda (alpha omega)
	    				     (let ((fn (vector (lambda (input) (* input (exp #C(0 1))))
	    						       (lambda (input) (* input #C(0 1)))
	    						       (lambda (input) (if (complexp input)
	    									   (complex (realpart input)
	    										    (- (imagpart input)))
	    									   input))
	    						       (lambda (input) input)
	    						       (lambda (input) (expt (- -1 (* 2 input))
	    									     1/2))
	    						       #'atanh #'acosh #'asinh
	    						       (lambda (input) (* (expt (/ (1+ input) (1- input))
	    										1/2)
	    									  (1+ input)))
	    						       #'atan #'acos #'asin
	    						       (lambda (input) (expt (- 1 (* 2 input))
	    									     1/2))
	    						       #'sin #'cos #'tan
	    						       (lambda (input) (expt (1+ (* 2 input))
	    									     1/2))
	    						       #'sinh #'cosh #'tanh
	    						       (lambda (input) (expt (- -1 (* 2 input))
	    									     1/2))
	    						       #'realpart #'abs #'imagpart #'phase)))
	    				       ;; the twelfth element of the vector corresponds to
	    				       ;; index 0, hence an offset of 12 from the vector's first element
	    				       (funcall (aref fn (+ 12 alpha))
	    						omega))))))
	    (\~ (has :titles ("Not" "Excluding"))
	    	(ambivalent (args :scalar (boolean-op (lambda (omega)
	    						(cond ((= 0 omega) t)
	    						      ((= 1 omega) nil)
	    						      (t (error
	    							  "Domain error: arguments to ~ must be 1 or 0."))))))
	    		    (args :any :any (lambda (alpha omega)
	    				      (let ((to-exclude (if (stringp omega)
	    							    (array-to-list omega)
	    							    (array-to-list (make-array
	    									    (list (array-total-size omega))
	    									    :displaced-to omega))))
	    					    (included nil))
	    					(aops:each (lambda (element)
	    						     ;;(print (list element to-exclude))
	    						     (if (not (member element to-exclude))
	    							 (setq included (cons element included))))
	    						   alpha)
	    					(make-array (list (length included))
	    						    :element-type (cond ((stringp alpha)
	    									 'character)
	    									(t t))
	    						    :initial-contents (reverse included))))))
	    	(tests (is "~1 0 1" #(0 1 0))
	    	       (is "1 2 3 4 5 6 7~3 5" #(1 2 4 6 7))
	    	       (is "'MACARONI'~'ALFREDO'" "MCNI")))
     	    (< (has :title "Less Than")
	       (dyadic (args :scalar (boolean-op <)))
	       (tests (is "3<1 2 3 4 5" #(0 0 0 1 1))))
     	    (≤ (has :title "Less or Equal")
	       (dyadic (args :scalar (boolean-op <=)))
	       (tests (is "3≤1 2 3 4 5" #(0 0 1 1 1))))
     	    (= (has :title "Equal")
	       (dyadic (args :scalar (boolean-op =)))
	       (tests (is "3=1 2 3 4 5" #(0 0 1 0 0))))
     	    (≥ (has :title "Greater or Equal")
	       (dyadic (args :scalar (boolean-op >=)))
	       (tests (is "3≥1 2 3 4 5" #(1 1 1 0 0))))
     	    (> (has :title "Greater")
	       (dyadic (args :scalar (boolean-op >)))
	       (tests (is "3>1 2 3 4 5" #(1 1 0 0 0))))
     	    (≠ (has :title "Not Equal")
	       (dyadic (args :scalar (boolean-op /=)))
	       (tests (is "3≠1 2 3 4 5" #(1 1 0 1 1))))
	    (≡ (has :titles ("Depth" "Match"))
	       (ambivalent (args :any array-depth)
	    		   (args :any :any (boolean-op equalp))))
	    (≢ (has :title "Not Match")
	       (ambivalent (args :any (lambda (omega) (first (dims omega))))
	    		   ;; TODO: equalp is not exactly right for this function
	    		   (args :any :any (boolean-op (lambda (alpha omega) (not (equalp alpha omega)))))))
	    (^ (has :title "And")
	       (dyadic (args :scalar lcm))
	       (tests (is "0 1 0 1 ^ 0 0 1 1" #(0 0 0 1))))
	    (∧ (has :title "And")
	       (dyadic (args :scalar lcm))
	       (tests (is "0 1 0 1 ∧ 0 0 1 1" #(0 0 0 1))))
	    (⍲ (Has :Title "Nand")
	       (dyadic (args :scalar (boolean-op (lambda (alpha omega) (not (and (= alpha 1) (= omega 1)))))))
	       (tests (is "0 1 0 1 ⍲ 0 0 1 1" #(1 1 1 0))))
	    (⍱ (has :title "Nor")
	       (dyadic (args :scalar gcd))
	       (tests (is "0 1 0 1 ⍱ 0 0 1 1" #(1 0 0 0))))
     	    (∨ (has :title "Or")
	       (dyadic (args :scalar (boolean-op (lambda (alpha omega) (not (and (= alpha 0) (= omega 0)))))))
	       (tests (is "0 1 0 1 ∨ 0 0 1 1" #(0 1 1 1))))
	    (⍳ (has :titles ("Index" "Index Of"))
	       (ambivalent (args :one (lambda (idiom omega)
	    				(make-array (list omega)
	    					    :initial-contents
	    					    (mapcar (lambda (i)
	    						      (+ i (of-environment idiom :count-from)))
	    						    (alexandria:iota omega)))))
	    		   (args :any :any index-of))
	       (tests (is "⍳5" #(1 2 3 4 5))
	    	      (is "3⍳1 2 3 4 5" #(2 2 1 2 2))))
     	    (⍴ (has :titles ("Shape" "Reshape"))
	       (ambivalent (args :any dims)
	    		   (args :any :any (lambda (alpha omega)
	    				     (reshape-array-fitting omega (array-to-list alpha)))))
	       (tests (is "4 5⍴⍳3" #2A((1 2 3 1 2) (3 1 2 3 1) (2 3 1 2 3) (1 2 3 1 2)))))
	    (∊ (has :titles ("Enlist" "Membership"))
	       (ambivalent (args :any enlist)
	    		   (args :any :any (lambda (alpha omega)
	    				     (let ((output (alexandria:copy-array alpha)))
	    				       (dotimes (index (array-total-size output))
	    					 (let ((found nil))
	    					   (aops:each (lambda (input)
	    							(if (= input (row-major-aref output index))
	    							    (setq found t)))
	    						      omega)
	    					   (setf (row-major-aref output index)
	    						 (if found 1 0))))
	    				       output))))
	       (tests (is "∊2 2 2⍴⍳9" #(1 2 3 4 5 6 7 8))
	    	      (is "2 5 7∊1 2 3 4 5" #(1 1 0))))
	    (↑ (has :titles ("Disclose" "Take"))
	       (ambivalent (args :any (lambda (omega)
	    				(if (or (not (vectorp omega))
	    					(not (arrayp (aref omega 0))))
	    				    omega (aref omega 0))))
	    		   (args :any :any :axes
	    			 (lambda (alpha omega &optional axes)
	    			   (multidim-slice omega (if axes (loop for axis from 0 to (1- (rank omega))
	    							     collect (if (= axis (1- (aref (first axes) 0)))
	    									 (aref alpha 0)
	    									 (nth axis (dims omega))))
	    						     (array-to-list alpha))
	    					   :fill-with 0))))
	       (tests (is "↑⊂1 2 3 4" #(1 2 3 4))
	    	      (is "2 3 4↑4 5 6⍴⍳9" #3A(((1 2 3 4) (7 8 9 1) (4 5 6 7))
	    				       ((4 5 6 7) (1 2 3 4) (7 8 9 1))))))
	    (↓ (has :titles ("Drop" "Split"))
	       (ambivalent (args :any :axes (lambda (omega &optional axes)
	    				      ;; NOTE: check this against another implementation
	    				      (aops:split omega (if axes (aref (first axes) 0)
	    							    (1- (rank omega))))))
	    		   (args :any :any :axes
	    			 (lambda (alpha omega &optional axes)
	    			   (multidim-slice omega (if axes (loop for axis from 0 to (1- (rank omega))
	    							     collect (if (= axis (1- (aref (first axes) 0)))
	    									 (aref alpha 0)
	    									 0))
	    						     (array-to-list alpha))
	    					   :inverse t))))
	       (tests (is "↓3 4⍴⍳9" #(#(1 2 3 4) #(5 6 7 8) #(9 1 2 3)))
	    	      (is "2 2 2↓4 5 6⍴⍳9" #3A(((3 4 5 6) (9 1 2 3) (6 7 8 9))
	    				       ((6 7 8 9) (3 4 5 6) (9 1 2 3))))))
	    (⌷ (has :title "Axis")
	       (dyadic (args :any :any (lambda (alpha omega)
	    				 (apply #'aref (cons omega (array-to-list alpha)))))))
	    (\, (has :titles ("Catenate" "Ravel"))
	    	(ambivalent (args :any (lambda (omega)
	    				 (if (vectorp omega)
	    				     omega (make-array (list (array-total-size omega))
	    						       :displaced-to omega))))
	    		    (args :any :any :axes
	    			  (lambda (alpha omega &optional axes)
	    			    (if (and (not axes)
	    				     (vectorp alpha)
	    				     (vectorp omega))
	    				(concatenate 'vector alpha omega)
	    				(aops:stack (if axes (1- (aref (first axes) 0))
	    						1)
	    					    alpha omega)))))
	    	(tests (is ",3 4⍴⍳9" #(1 2 3 4 5 6 7 8 9 1 2 3))
	    	       (is "(3 6⍴⍳6),3 4⍴⍳9" #2A((1 2 3 4 5 6 1 2 3 4) (1 2 3 4 5 6 5 6 7 8)
	    					 (1 2 3 4 5 6 9 1 2 3)))))
     	    (⍪ (has :titles ("Catenate First" "Table"))
	       (ambivalent (args :any (lambda (omega) (if (not (second (dims omega)))
	    						  (make-array (list (length omega) 1)
	    							      :initial-contents
	    							      (loop for i from 0 to (1- (length omega))
	    								 collect (list (aref omega i))))
	    						  omega)))
	    		   (args :any :any :axes
	    			 (lambda (alpha omega &optional axes)
	    			   (if (and (not axes)
	    				    (vectorp alpha)
	    				    (vectorp omega))
	    			       (if (not (= (length alpha)
	    					   (length omega)))
	    				   (error "Vectors must be of same length.")
	    				   (make-array (list 2 (length alpha))
	    					       :initial-contents (list (array-to-list alpha)
	    								       (array-to-list omega))))
	    			       (aops:stack (if axes (1- (aref (first axes) 0))
	    					       0)
	    					   alpha omega)))))
	       (tests (is "⍪3 4⍴⍳9" #2A((1 2 3 4) (5 6 7 8) (9 1 2 3)))
	    	      (is "(5 4⍴⍳6)⍪3 4⍴⍳9" #2A((1 2 3 4) (5 6 1 2) (3 4 5 6) (1 2 3 4)
	    					(5 6 1 2) (1 2 3 4) (5 6 7 8) (9 1 2 3)))))
	    (/ (has :title "Compress")
	       (dyadic (args :any :any :axes
	    		     (lambda (idiom alpha omega &optional axes)
	    		       (expand-array (array-to-list alpha)
	    				     omega (if axes (- (rank omega)
	    						       (- (aref (first axes) 0)
	    							  (1- (of-environment idiom :count-from)))))
	    				     0 :omit-zeroes t))))
	       (tests (is "1 0 1 0 1/⍳5" #(1 3 5))
	    	      (is "1 ¯2 3 ¯4 5/⍳5" #(1 0 0 3 3 3 0 0 0 0 5 5 5 5 5))))
	    (⌿ (has :title "Compress First")
	       (dyadic (args :any :any :axes
	    		     (lambda (idiom alpha omega &optional axes)
	    		       (expand-array (array-to-list alpha)
	    				     omega (if axes (- (rank omega)
	    						       (- (aref (first axes) 0)
	    							  (1- (of-environment idiom :count-from)))))
	    				     (1- (rank omega))
	    				     :omit-zeroes t)))))
	    (\\ (has :title "Expand")
	    	(dyadic (args :any :any :axes
	    		      (lambda (idiom alpha omega &optional axes)
	    			(expand-array (array-to-list alpha) ;[1] 1 [2] 0 / [0] 1 [1] 0
	    				      omega (if axes (- (rank omega)
	    							(- (aref (first axes) 0)
	    							   (1- (of-environment idiom :count-from)))))
	    				      0)))))
	    (⍀ (has :title "Expand First")
	       (dyadic (args :any :any :axes
	    		     (lambda (idiom alpha omega &optional axes)
	    		       (expand-array (array-to-list alpha)
	    				     omega (if axes (- (rank omega)
	    						       (- (aref (first axes) 0)
	    							  (1- (of-environment idiom :count-from)))))
	    				     (1- (rank omega)))))))
	    (⍷ (has :title "Find")
	       (dyadic (args :any :any find-array)))
	    (⊂ (has :titles ("Enclose" "Partition"))
	       (ambivalent (args :any (lambda (omega)
	    				(if (loop for dim in (dims omega) always (= 1 dim))
	    				    omega (make-array (list 1) :initial-element omega))))
	    		   (args :any :any (lambda (alpha omega)
	    				     (if (/= (length alpha) (length omega))
	    					 (error "Length mismatch.")
	    					 (let ((output nil)
	    					       (accumulator nil)
	    					       (partition-index 0))
	    					   (dotimes (index (length alpha))
	    					     (if (and (< 0 index)
	    						      (< partition-index (aref alpha index)))
	    						 (progn (setq output
	    							      (cons (make-array (list (length accumulator))
	    										:initial-contents
	    										(reverse accumulator))
	    								    output))
	    							(setq accumulator nil)))
	    					     (setq partition-index (aref alpha index))
	    					     (if (< 0 (aref alpha index))
	    						 (setq accumulator (cons (aref omega index)
	    									 accumulator))))
	    					   (if accumulator (setq output
	    								 (cons (make-array
	    									(list (length accumulator))
	    									:initial-contents
	    									(reverse accumulator))
	    								       output)))
	    					   (make-array (list (length output))
	    						       :initial-contents (reverse output)))))))
	       (tests (is "⊂3 4⍴⍳7" #(#2A((1 2 3 4) (5 6 7 1) (2 3 4 5))))
	    	      (is "1 1 2 2 2 3 3 3 3⊂⍳9" #(#(1 2) #(3 4 5) #(6 7 8 9)))))
	    (⊃ (has :titles ("Mix" "Pick"))
	       (ambivalent (args :any (lambda (omega)
	    				;; currently works for vectors only
	    				(let ((output (make-array
	    					       (list (length omega)
	    						     (apply #'max (array-to-list (aops:each #'length
	    											    omega)))))))
	    				  (dotimes (index (length omega))
	    				    (dotimes (sub-index (length (aref omega index)))
	    				      (setf (aref output index sub-index)
	    					    (aref (aref omega index) sub-index))))
	    				  output)))
	    		   (args :one :any (lambda (alpha omega)
	    				     (apply #'aref (cons omega (array-to-list (aref alpha 0))))))))
	    (∪ (has :titles ("Union" "Unique"))
	       (ambivalent (args :any (lambda (omega)
	    				(if (not (vectorp omega))
	    				    (error "Argument must be a vector.")
	    				    (let ((uniques nil))
	    				      (dotimes (index (length omega))
	    					(if (not (find (aref omega index)
	    						       uniques))
	    					    (setq uniques (cons (aref omega index)
	    								uniques))))
	    				      (make-array (list (length uniques))
	    						  :initial-contents (reverse uniques))))))
	    		   (args :any :any (lambda (alpha omega)
	    				     (if (or (not (vectorp alpha))
	    					     (not (vectorp omega)))
	    					 (error "Arguments must be vectors.")
	    					 (let ((uniques nil))
	    					   (dotimes (index (length omega))
	    					     (if (not (find (aref omega index)
	    							    alpha))
	    						 (setq uniques (cons (aref omega index)
	    								     uniques))))
	    					   (concatenate 'vector alpha
	    							(make-array (list (length uniques))
	    								    :initial-contents
	    								    (reverse uniques)))))))))
	    (∩ (has :title "Intersection")
	       (dyadic (args :any :any (lambda (alpha omega)
	    				 (if (or (not (vectorp alpha))
	    					 (not (vectorp omega)))
	    				     (error "Arguments must be vectors.")
	    				     (let ((matches nil))
	    				       (dotimes (index (length alpha))
	    					 (if (find (aref alpha index)
	    						   omega)
	    					     (setq matches (cons (aref alpha index)
	    								 matches))))
	    				       (make-array (list (length matches))
	    						   :initial-contents (reverse matches))))))))
	    (⌽ (has :titles ("Reverse" "Rotate"))
	       (ambivalent (args :any :axes (lambda (omega &optional axes)
	    				      (if (vectorp omega)
	    					  (let ((new-array (copy-array omega)))
	    					    (funcall (make-rotator)
	    						     new-array)
	    					    new-array)
	    					  (if (arrayp omega)
	    					      (apply-marginal (make-rotator)
	    							      omega (if axes (1- (aref (first axes) 0)))
	    							      (1- (rank omega)))))))
	    		   (args :one :any :axes
	    			 (lambda (alpha omega &optional axes)
	    			   (if (vectorp omega)
	    			       (let ((new-array (copy-array omega)))
	    				 (funcall (make-rotator alpha)
	    					  new-array)
	    				 new-array)
	    			       (if (arrayp omega)
	    				   (apply-marginal (make-rotator alpha)
	    						   omega (if axes (1- (aref (first axes) 0)))
	    						   (1- (rank omega))))))))
	       (tests (is "⌽1 2 3 4 5" #(5 4 3 2 1))
	    	      (is "⌽3 4⍴⍳9" #2A((4 3 2 1) (8 7 6 5) (3 2 1 9)))
	    	      (is "2⌽3 4⍴⍳9" #2A((3 4 1 2) (7 8 5 6) (2 3 9 1)))))
     	    (⊖ (has :titles ("Reverse First" "Rotate First"))
	       (ambivalent (args :any :axes (lambda (omega &optional axes)
	    				      (if (vectorp omega)
	    					  (let ((new-array (copy-array omega)))
	    					    (funcall (make-rotator)
	    						     new-array)
	    					    new-array)
	    					  (if (arrayp omega)
	    					      (apply-marginal (make-rotator)
	    							      omega (if axes (1- (aref (first axes) 0)))
	    							      0)))))
	    		   (args :one :any :axes
	    			 (lambda (alpha omega &optional axes)
	    			   (if (vectorp omega)
	    			       (let ((new-array (copy-array omega)))
	    				 (funcall (make-rotator alpha)
	    					  new-array)
	    				 new-array)
	    			       (if (arrayp omega)
	    				   (apply-marginal (make-rotator alpha)
	    						   omega (if axes (1- (aref (first axes) 0)))
	    						   0))))))
	       (tests (is "⊖1 2 3 4 5" #(5 4 3 2 1))
	    	      (is "⊖3 4⍴⍳9" #2A((9 1 2 3) (5 6 7 8) (1 2 3 4)))
	    	      (is "1⊖3 4⍴⍳9" #2A((5 6 7 8) (9 1 2 3) (1 2 3 4)))))
	    (⍉ (has :titles ("Reverse Axes" "Transpose"))
	       (ambivalent (args :any (lambda (omega)
	    				(aops:permute (reverse (alexandria:iota (rank omega)))
	    					      omega)))
	    		   (args :any :any (lambda (idiom alpha omega)
	    				     (aops:permute (mapcar (lambda (i)
	    							     (- i (of-environment idiom
	    										  :count-from)))
	    							   (array-to-list alpha))
	    						   omega)))))
            ;; TODO: dyadic functions of ⍋⍒ only support vectors as a right argument
	    (⍋ (has :titles ("Grade Up" "Grade Up By"))
	       (ambivalent (args :any (lambda (omega) (grade omega (alpha-compare #'<=))))
	    		   (args :any :any (lambda (alpha omega) (grade (index-of alpha omega)
	    								(alpha-compare #'<))))))
	    (⍒ (has :titles ("Grade Down" "Grade Down By"))
	       (ambivalent (args :any (lambda (omega) (grade omega (alpha-compare #'>=))))
	    		   (args :any :any (lambda (alpha omega) (grade (index-of alpha omega)
	    								(alpha-compare #'>))))))
	    ;; TODO: inversion does not yet work for non-square matrices
	    (⌹ (has :titles ("Matrix Inverse" "Matrix Divide"))
	       (ambivalent (args :any (lambda (omega)
	    				(if (and (= 1 (rank omega))
	    					 (= 1 (length omega)))
	    				    (/ (aref omega 0))
	    				    (invert-matrix omega))))
	    		   ;; TODO: problems apparent with matrix divide
	    		   (args :any :any (lambda (alpha omega) (array-inner-product (invert-matrix omega)
	    									      alpha #'* #'+))))
	       (tests (is "⌹2 2⍴4 9 8 2" #2A((-1/32 9/64) (1/8 -1/16)))))
	    (⊤ (has :title "Encode")
	       (dyadic (args :any :any (lambda (alpha omega)
	    				 (flet ((rebase (bases number)
	    					  (let ((operand number)
	    						(last-base 1)
	    						(base 1)
	    						(component 1)
	    						(element nil))
	    					    (loop for index from (1- (length bases)) downto 0
	    					       do (setq last-base base
	    							base (* base (aref bases index))
	    							component (if (= 0 base)
	    								      operand
	    								      (* base
	    									 (nth-value 1 (floor (/ operand
	    												base)))))
	    							operand (- operand component)
	    							element (/ component last-base))
	    					       collect element))))
	    				   (if (= 1 (length omega))
	    				       (let ((result (rebase alpha (aref omega 0))))
	    					 (make-array (list (length result))
	    						     :initial-contents (reverse result)))
	    				       (aops:permute (list 1 0)
	    						     (make-array (list (length omega) (length alpha))
	    								 :initial-contents
	    								 (mapcar (lambda (item)
	    									   (reverse (rebase alpha item)))
	    									 (array-to-list omega))))))))))
	    (⊥ (has :title "Decode")
	       (dyadic (args :any :any (lambda (alpha omega)
	    				 (flet ((rebase (bases numerators)
	    					  (let ((result 0)
	    						(base 1))
	    					    (loop for index from (1- (length numerators)) downto 0
	    					       do (incf result (* base (aref numerators index)))
	    						 (setf base (* base (aref bases index))))
	    					    result)))
	    				   (let ((bases (if (= 1 (length alpha))
	    						    (make-array (list (first (dims omega)))
	    								:initial-element (aref alpha 0))
	    						    (if (not (= (length alpha)
	    								(let ((d-o (dims omega)))
	    								  (if (= 1 (length d-o))
	    								      (first d-o)
	    								      (second d-o)))))
	    							(error "Base/element length mismatch.")
	    							alpha))))
	    				     (if (= 1 (rank omega))
	    					 (rebase bases omega)
	    					 (aops:margin (lambda (sub-array) (rebase bases sub-array))
	    						      omega 0))))))))
	    (⍎ (has :title "Evaluate")
	       (monadic (args :any (lambda (idiom omega)
				     (eval (vex-program idiom nil omega))))))
	    (∘ (has :title "Find Outer Product, Not Inner")
	       (symbolic :outer-product-designator))
	       ))
