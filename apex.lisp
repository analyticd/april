;;;; apex.lisp

(in-package #:apex)
 
(defun is-singleton (value)
  "Determine whether an array is a singleton, i.e. possesses just one member."
  (or (and (atom value)
	   (not (arrayp value)))
      ;; non-array atoms are considered singleton values
      (let ((adims (dims value)))
	(and (= 1 (first adims))
	     (= 1 (length adims))))))

(defun apply-scalar-monadic (function omega)
  "Apply a scalar function across a single arguments, iterating over multidimensional and nested arrays."
  (labels ((apply-fn (arg) (if (arrayp arg)
			       (aops:each #'apply-fn arg)
			       (funcall function arg))))
    (aops:each #'apply-fn omega)))

(defun apply-scalar-dyadic (function alpha omega)
  "Apply a scalar function across objects as appropriate in APL. Handles scalars as well as nested and multidimensional arrays."
  (let* ((alpha-scalar? (not (arrayp alpha)))
	 (omega-scalar? (not (arrayp omega)))
	 (alpha-unitary? (and (not alpha-scalar?)
			      (vectorp alpha)
			      (= 1 (length alpha))))
	 (omega-unitary? (and (not omega-scalar?)
			      (vectorp omega)
			      (= 1 (length omega)))))
    (cond ((and alpha-scalar? omega-scalar?)
	   (funcall function alpha omega))
	  ((and alpha-unitary? omega-unitary?)
	   (aops:each (lambda (alpha omega) (apply-scalar-dyadic function alpha omega))
		      alpha omega))
	  ((and (not alpha-unitary?)
		(not omega-unitary?)
		(not alpha-scalar?)
		(not omega-scalar?))
	   (if (loop for dimension in (funcall (lambda (a o) (mapcar #'= a o))
					       (dims alpha)
					       (dims omega))
		  always dimension)
	       (aops:each (lambda (alpha omega) (apply-scalar-dyadic function alpha omega))
			  alpha omega)
	       (error "Array size mismatch.")))
	  (t (labels ((scan-over (element)
			(if (arrayp element)
			    (aops:each #'scan-over element)
			    (apply (lambda (left right) (apply-scalar-dyadic function left right))
				   (cond (alpha-scalar? (list alpha element))
					 (alpha-unitary? (list (aref alpha 0)
							       element))
					 (omega-scalar? (list element omega))
					 (omega-unitary? (list element (aref omega 0))))))))
	       (aops:each #'scan-over (if (or alpha-scalar? alpha-unitary?)
					  omega alpha)))))))

(defmacro mediate-operation (operation)
  "Process the spec for a function or operator, building a function to process its arguments and generate code to run the operation."
  (flet ((mediate-arguments (operation arg-specs a-sym &optional o-sym)
	   ;; moderate arguments to a Vex function at compile time
	   (let* ((alpha-sym o-sym)
		  (omega-sym a-sym)
		  (fn (if (and (listp operation)
			       (macro-function (first operation))
			       (not (eql 'lambda (first operation))))
			  (macroexpand (append operation (if (second arg-specs)
							     (list omega-sym alpha-sym)
							     (list omega-sym))))
			  `(function ,operation))))
	     (if (eq :scalar (first arg-specs))
		 ;; for a scalar function, return both monadic and dyadic variants if applicable
		 (if (eq :dyadic (second arg-specs))
		     ``(funcall #'apply-scalar-dyadic ,,fn ,(macroexpand ,alpha-sym)
				,(macroexpand ,omega-sym))
		     ``(funcall #'apply-scalar-monadic ,,fn ,(macroexpand ,omega-sym)))
		 ;; assign the alpha, omega and axis argument specs
		 (let ((alpha (if (and (second arg-specs)
				       (not (eq :axes (second arg-specs))))
				  (first arg-specs)))
		       (omega (if (or (not (second arg-specs))
				      (eq :axes (second arg-specs)))
				  (first arg-specs)
				  (second arg-specs)))
		       (axes (if (eq :axes (second arg-specs))
				 (second arg-specs)
				 (third arg-specs))))
		   ``(if (and ,,@(cond ((eq :one omega)
					`(`(is-singleton ,(macroexpand ,omega-sym))))
				       ((eq :sym omega)
					`(`(symbolp (quote ,(if (listp (macroexpand ,omega-sym))
								(second (getf (macroexpand ,omega-sym)
									      :initial-contents))
								(macroexpand ,omega-sym)))))))
			      ,,@(if (and alpha (not (eq :any alpha)))
				     (if (eq :one alpha)
					 `(`(is-singleton ,(macroexpand ,alpha-sym))))))
			 ;; if the arguments are scalar (:one), remove them from their arrays for evaluation
			 (funcall ,,fn
				  ,,@(if alpha (list (cond ((eq :one alpha)
							    ``(aref ,(macroexpand ,alpha-sym) 0))
							   ((eq :axes alpha)
							    (cons 'list (macroexpand axes)))
							   ;; alpha is equal to :axes when
							   ;; axes are used for a monadic function
							   (t `(macroexpand ,alpha-sym)))))
				  ,,(cond ((eq :one omega)
					   ``(if (arrayp ,(macroexpand ,omega-sym))
						 (aref ,(macroexpand ,omega-sym) 0)
						 ,(macroexpand ,omega-sym)))
					  ((eq :sym omega)
					   ``(quote ,(if (listp (macroexpand ,omega-sym))
							 (second (getf (macroexpand ,omega-sym)
								       :initial-contents))
							 (macroexpand ,omega-sym))))
					  (t `(macroexpand ,omega-sym)))
				  ,,@(if axes (list ``(list ,@(macroexpand axes)))))))))))
  (let* ((operation-name (intern (string-upcase (first operation))
				 "KEYWORD"))
	 (alpha-sym (intern "ALPHA"))
	 (omega-sym (intern "OMEGA"))
	 (valencies (rest operation))
	 (mediated (if (or (eq :symmetric-scalar (first valencies))
			   (eq :asymmetric-scalar (first valencies)))
		       (list (mediate-arguments (if (third valencies)
						    (third valencies)
						    (second valencies))
						(list :scalar :dyadic)
						alpha-sym omega-sym)
			     (mediate-arguments (second valencies)
						(list :scalar :monadic)
						omega-sym))
		       (append (if (second valencies)
		       		   (list (mediate-arguments (first (last (second valencies)))
		       					    (butlast (rest (second valencies)))
		       					    alpha-sym omega-sym)))
		       	       (let ((arg-specs (butlast (rest (first valencies)))))
		       		 (list (apply #'mediate-arguments
		       			      (append (list (first (last (first valencies))))
						      (list (append arg-specs
								    (if (and (eq :scalar (first arg-specs))
									     (eq :dyadic operation-name))
									(list :dyadic))))
						      (append (if (eq :dyadic operation-name)
								  (list alpha-sym))
							      (list omega-sym))))))))))
    `(lambda (meta axes omega &optional alpha)
       (declare (ignorable meta axes alpha))
       ,(cond ((eq :monadic operation-name)
	       `(if alpha
		    `(progn (error "Valence error - monadic operation."))
		    ,(first mediated)))
	      ((eq :dyadic operation-name)
	       `(if alpha
		    ,(first mediated)
		    `(error "Valence error - dyadic operation.")))
	      ((eq :ambivalent operation-name)
	       `(if alpha ,@mediated)))))))

(defun numeric-string-p (string)
  (handler-case (progn (parse-apl-number-string string) t)
    (condition () nil)))

(defun parse-apl-number-string (number-string &optional imaginary-component)
  (let ((nstring (string-upcase number-string)))
    (if (and (not imaginary-component)
	     (find #\J nstring))
	(let ((halves (cl-ppcre:split "J" nstring)))
	  (if (and (= 2 (length halves))
		   (< 0 (length (first halves)))
		   (< 0 (length (second halves))))
	      (complex (parse-apl-number-string (first halves) t)
		       (parse-apl-number-string (second halves) t))))
	;; either the macron or combining_macron character may be used as the high minus sign
	(parse-number:parse-number (regex-replace-all "[¯̄]" nstring "-")))))

(defun format-value (meta element)
  (cond ((and (vectorp element)
	      (string= element "⍬")) ;; APL's "zilde" character translates to an empty vector
 	 (make-array (list 0)))
	((and (vectorp element)
	      (or (string= element "⍺")
		  (string= element "⍵"))) ;; alpha and omega characters are directly changed to symbols
 	 (intern element))
	((numeric-string-p element)
	 (parse-apl-number-string element))
	((or (and (char= #\" (aref element 0))
		  (char= #\" (aref element (1- (length element)))))
	     (and (char= #\' (aref element 0))
		  (char= #\' (aref element (1- (length element))))))
	 (subseq element 1 (1- (length element))))
	((stringp element)
	 (if (not (gethash :variables meta))
	     (setf (gethash :variables meta)
		   (make-hash-table :test #'eq)))
	 (let ((variable-found (gethash (intern element "KEYWORD")
					(gethash :variables meta))))
	   (if variable-found
	       variable-found
	       ;; create a new variable if no variable is found matching the string
	       (setf (gethash (intern element "KEYWORD")
			      (gethash :variables meta))
		     (gensym)))))
	(t element)))

(defun format-array (values)
  (if (or (stringp (first values))
	  (symbolp (first values))
	  (and (not (second values))
	       (or (listp (first values))
		   (functionp (first values)))))
      ;; if the first item is a list (i.e. code to generate an array of some kind),
      ;; pass it through with no changes. Also pass through strings, which are already arrays,
      ;; any symbols
      (first values)
      `(make-array (list ,(length values))
		   :initial-contents (list ,@values))))

(defun format-function (idiom-name content)
  (let ((⍺ (intern "⍺" idiom-name))
	(⍵ (intern "⍵" idiom-name)))
    `(lambda (,⍺ &optional ,⍵)
       ;; kludge to handle reversing the variable order
       ;; the latter variable is always the optional one in Lisp, but in APL
       ;; the ⍺ is the optional argument
       (if ,⍵ (funcall (lambda (,⍺ ,⍵)
			 (declare (ignorable ,⍺))
			 ,content)
		       ,⍵ ,⍺)
	     (funcall (lambda (,⍵) ,content) ,⍺)))))

(defun assemble-value (idiom meta subprocessor precedent exp &optional output)
  ;; (print (list :exp exp output))
  (if (or (not exp)
	  (and (symbolp (first exp))
	       (member (first exp)
		       (gethash :functions meta)))
	  (and (listp (first exp))
	       (keywordp (caar exp))
	       (if (eq :fndef (caar exp))
		   (or output precedent)
		   t)))
      (values (cond ((and (listp (first exp))
			  (eq :fn (caar exp))
			  (and (not output)
			       (not precedent)))
		     :fun-comp)
		    ((not output) nil)
		    ;; disclose strings since they're treated as arrays
		    ((and (= 1 (length output))
			  (stringp (first output)))
		     (first output))
		    ;; disclose function definition objects
		    ((and (listp (first output))
			  (eq :fndef (caar output)))
		     output)
		    ;; disclose arrays and lists (which specify computed values)
		    ;; disclose single symbols since any value they represent will be vectorized
		    ((and (= 1 (length output))
			  (or (symbolp (first output))
			      (listp (first output))
			      (arrayp (first output))))
		     (first output))
		    (t (cons 'vector output)))
	      (if (and (symbolp (first exp))
		       (member (first exp)
			       (gethash :functions meta)))
		  ;; wrap a function-referencing symbol in a list before sending it
		  ;; to assembleOperation
		  (cons (list :fnref (first exp))
			(rest exp))
		  exp))
      (assemble-value idiom meta subprocessor precedent (rest exp)
		      (cons (if (and (listp (first exp))
				     (not (eq :fndef (caar exp))))
				(cons 'progn (mapcar (lambda (sub-exp) (funcall subprocessor
										idiom meta sub-exp))
						     (first exp)))
				(first exp))
			    output))))

(defun assemble-operation (idiom meta exp &optional output)
  ;; (print (list :xx exp output))
  (let ((first-out (first output)))
    (if (or (not exp)
	    ;; break on atoms or sub-lists
	    (not (listp (first exp)))
	    (not (keywordp (caar exp))))
	(progn (cond ((and (eq :op (caar output))
			   ;; (member (first (last (first output)))
			   ;; 	   (idiom-overloaded-lexicon idiom))
			   (of-overloaded? idiom (first (last (first output))))
			   (or (= 1 (length output))
			       (and (= 2 (length output))
				    (eq :axes (caadr output)))))
		      ;; (print (list :oo output))
		      ;; convert an interpreted operator to the overloaded function of the same
		      ;; name if it appears in context as a function, i.e. with no accompanying
		      ;; function to apply to the adjacent operand(s)
		      (let ((glyph (first (last (first output)))))
			(setf (first output)
			      (if (and (= 2 (length output))
				       (eq :axes (caadr output)))
				  (list :fn (list
					     (lambda (meta axes omega &optional alpha)
					       (declare (ignore axes))
					       (funcall (first (of-functions idiom glyph)
							       ;;(gethash glyph (idiom-functions idiom))
							       )
							meta (list (cadadr output))
							omega alpha))))
				  (list :fn (of-functions idiom glyph)
					;;(gethash glyph (idiom-functions idiom))
					))))))
	       (values output exp))
	(let ((processed (cond ((eq :fnref (caar exp))
				(list :fnref
				      (list (lambda (meta axes omega &optional alpha)
					      (declare (ignore meta)
						       (ignorable axes alpha))
					      `(funcall ,(cadar exp)
							,omega ,@(if alpha (list alpha)))))))
			       ((eq :fndef (caar exp))
				;;(print (list :exo exp output))
				(cond ((not output)
				       (list :fndef (cadar exp)))
				      ((and (eq :op (caar output))
					    (eq :right (cadar output)))
				       (print (list :eq (caadar exp)))
				       (list :fn-composed
					     (list (funcall (third (first output))
							    meta nil (list (cadar exp))))))))
			       ((eq :fn (caar exp))
				(cond ((not output)
				       (list :fn ;; (gethash (cadar exp)
						 ;; 	  (idiom-functions idiom))
					     (of-functions idiom (cadar exp))))
				      ((and (= 1 (length output))
					    (eq :axes (caar output)))
				       (list :fn
					     (list
					      (lambda (meta axes omega &optional alpha)
						(declare (ignore axes))
						(funcall (first ;; (gethash (cadar exp)
								;; 	 (idiom-functions idiom))
								(of-functions idiom (cadar exp)))
							 meta (list (cadar output))
							 omega alpha)))))
				      ((and (eq :op (caar output))
					    (eq :right (cadar output)))
				       (list :fn-composed
					     (list
					      (funcall (third (first output))
						       meta nil (list ;; (gethash (cadar exp)
								      ;; 	       (idiom-functions idiom))
								      (of-functions idiom (cadar exp)))))))
				      ((and (eq :op (caar output))
					    (eq :center (cadar output)))
				       (list :fn-composed
					     (list
					      (funcall (third (first output))
						       meta nil (list (cadadr output)
								      ;; (gethash (cadar exp)
								      ;; 	       (idiom-functions idiom))
								      (of-functions idiom (cadar exp)))))))
				      ((eq :fndef (first first-out))
				       ;;(print (list :si first-out exp))
				       (funcall (first (last ;; (gethash (cadar exp)
							     ;; 	      (idiom-functions idiom))
							     (of-functions idiom (cadar exp))))
						(second first-out)))))
			       ((eq :op (caar exp))
				;; in case of a function-overloaded operator following a central
				;; operator, fetch its corresponding function and compose with
				;; the central operator
				(cond ((and (eq :op (caar output))
					    ;; (member (first (last (first exp)))
					    ;; 	    (idiom-overloaded-lexicon idiom))
					    (of-overloaded? idiom (first (last (first exp)))))
				       (let ((function ;; (gethash (first (last (first exp)))
						       ;; 		(idiom-functions idiom))
					       (of-functions idiom (first (last (first exp))))))
					 (list :fn-composed
					       (list (funcall (third (first output))
							      meta nil (list (cadadr output)
									     function))))))
				      (t (list :op (first (rest (first exp)))
					       (if (and (= 1 (length output))
							(eq :axes (caar output)))
						   (lambda (meta axes functions)
						     (declare (ignore axes))
						     (funcall ;; (gethash (second (rest (first exp)))
							      ;; 	       (idiom-operators idiom))
							      (of-operators idiom (second (rest (first exp))))
							      meta (cons 'list (cdar output))
							      functions))
						   ;; (gethash (second (rest (first exp)))
						   ;; 	    (idiom-operators idiom))
						   (of-operators idiom (second (rest (first exp)))))
					       (caddar exp)))))
			       ((eq :axes (caar exp))
				(first exp)))))
	  (if (and (eq :fn (caar exp))
		   (listp (second exp))
		   (or (eq :fn (caadr exp))
		       (and (eq :op (caadr exp))
			    (eq :right (cadadr exp)))))
	      (values (cons processed output)
		      (rest exp))
	      (assemble-operation idiom meta (rest exp)
				  (cons processed output)))))))

(vex-spec
 apex
 (state :count-from 1
	:atomic-vector
	(concatenate 'string "!\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`"
		     "abcdefghijklmnopqrstuvwxyz{|}~¥€⇄∧∼≬⋆⋸⌸⌺⌼⌾⍁¡⍣⍅⎕⍞⌹⍆⍤⍇⍈⍊⊤λ⍍⍏£⊥⍶⌶⍐⍑χ≢⍖⍗"
		     "⍘⍚⍛⌈⍜⍢∪⍨⍕⍎⍬⍪∣│┤⍟∆∇→╣║╗╝←⌊┐└┴┬├─┼↑↓╔╚╩╦╠═╬≡⍸⍷∵⌷⍂⌻⊢⊣◊┘┌█▄▌▐▀"
		     "⍺⍹⊂⊃⍝⍲⍴⍱⌽⊖○∨⍳⍉∈∩⌿⍀≥≤≠×÷⍙∘⍵⍫⍋⍒¯¨"))
 (utilities :match-blank-character
	    (lambda (char) (member char (list #\  #\Tab)))
	    :match-newline-character
	    (lambda (char) (member char (list #\◊ #\Newline #\Return)))
	    :match-token-character
	    (lambda (char)
	      ;; the ¯ character must be expressed as #\macron to be correctly processed
	      ;; the ̄ (combining_macron) character can be denoted normally, however
	      (or (alphanumericp char)
		  (member char (list #\macron #\̄ #\. #\⍺ #\⍵ #\⍬))))
	    :prep-code-string
	    (lambda (string)
	      ;; remove comments, including comment-only lines
	      (regex-replace-all (concatenate 'string "^\\s{0,}⍝(.*)[\\r\\n]|(?<=[\\r\\n])\\s{0,}⍝(.*)[\\r\\n]"
					      ;;"|^\\s{0,}[\\r\\n]"
					      ;;"|(?<=[\\r\\n])\\s{0,}⍝(.*)[\\r\\n]"
					      ;;"|(?<=[\\r\\n])\\s{0,}[\\r\\n]"
					      "|(?<=[^\\r\\n])\\s{0,}⍝(.*)(?=[\\r\\n])")
				 string ""))
	    :format-value #'format-value
	    :format-object #'format-array
	    :format-function #'format-function
	    :mediate-operation-macro 'mediate-operation
	    :assemble-value #'assemble-value
	    :assemble-operation #'assemble-operation
	    :apply-scalar-monadic #'apply-scalar-monadic
	    :apply-scalar-dyadic #'apply-scalar-dyadic)
 (operators (/ (has :title "Reduce")
	       (right (lambda (meta unused omega &optional alpha)
			(declare (ignore alpha unused))
			;; (print (list 90 omega alpha functions
			;; 	     (first (last (first functions)))
			;; 	     ))
			`(let ((new-array (copy-array ,omega)))
			   (if (= 1 (rank new-array))
			       (vector (reduce ;; ,(first (last (first functions)))
					       (lambda (alpha omega)
						 ,(funcall (caar functions)
							   meta nil 'omega 'alpha))
					       new-array))
			       (aops:margin (lambda (sub-array) (reduce (lambda (alpha omega)
									  ,(funcall (caar functions)
										    meta nil 'alpha 'omega))
									sub-array))
					    new-array (if ,axes (1- (aref (first ,axes) 0))
							  (1- (rank new-array))))))))
 	       (tests (is "+/1 2 3 4 5" #(15))
 		      (is "+/3 4⍴⍳12" #(10 26 42))
 		      (is "+/[1]3 4⍴⍳12" #(15 18 21 24))))
  	    (⌿ (has :title "Reduce First")
	       (right (lambda (meta unused omega &optional alpha)
			(declare (ignore alpha unused))
			`(let ((new-array (copy-array ,omega)))
			   (if (= 1 (rank new-array))
			       (vector (reduce (lambda (alpha omega)
						 ,(funcall (caar functions)
							   meta nil 'omega 'alpha))
					       new-array))
			       (aops:margin (lambda (sub-array) (reduce (lambda (alpha omega)
									  ,(funcall (caar functions)
										    meta nil 'alpha 'omega))
									sub-array))
					    new-array (if ,axes (1- (aref (first ,axes) 0))
							  0))))))
 	       (tests (is "+⌿3 4⍴⍳12" #(15 18 21 24))))
 	    (\\ (has :title "Scan")
		(right (lambda (meta unused omega &optional alpha)
			 (declare (ignore alpha unused))
			 `(if (vectorp ,omega)
			      (funcall (make-back-scanner (lambda (alpha omega)
							    ,(funcall (caar functions)
								      meta nil 'alpha 'omega)))
				       ,omega)
			      (if (arrayp ,omega)
				  (apply-marginal (make-back-scanner (lambda (alpha omega)
								       ,(funcall (caar functions)
										 meta nil 'alpha 'omega)))
						  ,omega (if ,axes (1- (aref (first ,axes) 0)))
						  (1- (rank ,omega)))))))
 	    	(tests (is "+\\1 2 3 4 5" #(1 3 6 10 15))
 	    	       (is "+\\3 4⍴⍳12" #2A((1 3 6 10) (5 11 18 26) (9 19 30 42)))))
 	    (⍀ (has :title "Scan First")
	       (right (lambda (meta unused omega &optional alpha)
			(declare (ignore alpha unused))
			`(if (vectorp ,omega)
			     (funcall (make-back-scanner (lambda (alpha omega)
							   ,(funcall (caar functions)
								     meta nil 'alpha 'omega)))
				      ,omega)
			     (if (arrayp ,omega)
				 (apply-marginal (make-back-scanner (lambda (alpha omega)
								      ,(funcall (caar functions)
										meta nil 'alpha 'omega)))
						 ,omega (if ,axes (1- (aref (first ,axes) 0)))
						 0)))))
 	       (tests (is "+⍀1 2 3 4 5" #(1 3 6 10 15))
 	    	      (is "+⍀3 4⍴⍳12" #2A((1 2 3 4) (6 8 10 12) (15 18 21 24)))))
 	    (\. (has :title "Inner/Outer Product")
		(center (lambda (meta axes omega &optional alpha)
			  (declare (ignore axes))
			  (if (eq :outer-product-designator (second functions))
			      `(aops:outer (lambda (alpha omega)
					     ,(funcall (caar functions)
						       meta nil 'alpha 'omega))
					   ,omega ,alpha)
			      `(if (and (vectorp ,omega)
					(vectorp ,alpha))
				   ;; TODO: improve logic for the argument?
				   (make-array (list 1)
					       :initial-element
					       (reduce (lambda (alpha omega)
							 ,(funcall (caadr functions)
								   meta nil 'alpha 'omega))
						       (aops:each (lambda (alpha omega)
								    ,(funcall (caar functions)
									      meta nil 'alpha 'omega))
								  ,alpha ,omega)))
				   (array-inner-product ,omega ,alpha
							(let ((f1 (lambda (alpha omega)
								    ,(funcall (caar functions)
									      meta nil 'alpha 'omega))))
							  (lambda (arg1 arg2)
							    (if (or (arrayp arg1)
								    (arrayp arg2))
								(apply-scalar-dyadic f1 arg1 arg2)
								(funcall f1 arg1 arg2))))
							(lambda (alpha omega)
							  ,(funcall (caadr functions)
								    meta nil 'alpha 'omega)))))))
 	    	(tests (is "2 3 4+.×8 15 21" #(145))
	    	       (is "2 3 4+.×3 3⍴3 1 4 1 5 9 2 6 5" #(17 41 55))
	    	       (is "(3 3⍴3 1 4 1 5 9 2 6 5)+.×2 3 4" #(25 53 42))
 	    	       (is "4 5 6∘.+20 30 40 50" #2A((24 34 44 54) (25 35 45 55) (26 36 46 56)))))
 	    (\¨ (has :title "Each")
		(right (lambda (meta axes omega &optional alpha)
			 (declare (ignore axes))
			 (let ((placeholder nil))
			   (if alpha (setq placeholder omega
					   omega alpha
					   alpha placeholder))
			   `(let ((new-array (copy-array ,omega)))
			      ,(if alpha
				   `(let ((right-arg ,alpha))
				      (make-array (dims right-arg)
						  :initial-contents
						  (loop for index from 0 to (1- (length right-arg))
						     collect (funcall (lambda (alpha omega)
									,(funcall (caar functions)
										  meta nil 'alpha 'omega))
								      (vector (aref right-arg index))
								      (aref new-array 0)))))
				   `(aops:each (lambda (item) (funcall (lambda (omega)
									 ,(funcall (caar functions)
										   meta nil 'omega))
								       item))
					       new-array))))))
 	   	(tests (is "⍳¨1 2 3" #(#(1) #(1 2) #(1 2 3)))
		       (is "1 ¯1 ⌽¨⊂1 2 3 4 5" #(#(2 3 4 5 1) #(5 1 2 3 4)))))
 	   (⍨ (has :title "Commute")
	      (right (lambda (meta axes omega &optional alpha)
		       (funcall (caar functions)
				meta axes (if alpha alpha omega)
				omega)))
 	      (tests (is "5-⍨10" #(5))))
 	   (∘ (has :title "Composition")
 	      ;; (center (macro (lambda (meta axes functions operand &optional right-operand)
 	      ;; 		       (declare (ignore meta axes))
 	      ;; 		       (if (and (first functions)
 	      ;; 				(second functions))
	      ;; 			   (if (eq :fun-comp operand)
	      ;; 			       (if right-operand
	      ;; 				   `(lambda (alpha omega)
	      ;; 				      (funcall ,(third (second functions))
	      ;; 					       omega (funcall ,(second (first functions))
	      ;; 							      alpha)))
	      ;; 				   `(lambda (omega)
	      ;; 				      (funcall ,(cadadr functions)
	      ;; 					       (funcall ,(cadar functions)
	      ;; 							omega))))
	      ;; 			       (if right-operand
	      ;; 				   `(apply-scalar-dyadic ,(third (second functions))
	      ;; 							 ,operand (apply-scalar-monadic
	      ;; 								   ,(second (first functions))
	      ;; 								   ,right-operand))
	      ;; 				   `(apply-scalar-monadic ,(cadadr functions)
	      ;; 							  (apply-scalar-monadic ,(cadar functions)
	      ;; 										,operand))))))))
	      (center (lambda (meta axes omega &optional alpha)
			(declare (ignore axes))
			;;(print (list :oo omega alpha functions))
			(if (and (first functions)
				 (second functions))
			    (if (eq :fun-comp omega)
				(if alpha
				    `(lambda (alpha omega)
				       (funcall ;;,(third (second functions))
					(lambda (alpha omega)
					  ,(funcall (caar functions)
						    meta nil 'alpha 'omega))
					omega (funcall ;;,(second (first functions))
					       (lambda (omega)
						 ,(funcall (caadr functions)
							   meta nil 'omega))
					       alpha)))
				    `(lambda (omega)
				       (funcall ;;,(cadadr functions)
					(lambda (omega)
					  ,(funcall (caadr functions)
						    meta nil 'omega))
					(funcall ;;,(cadar functions)
					 (lambda (omega)
					   ,(funcall (caar functions)
						     meta nil 'omega))
					 omega))))
				(if alpha
				    `(apply-scalar-dyadic ,(third (second functions))
							  ,omega (apply-scalar-monadic
								  ,(second (first functions))
								  ,alpha))
				    `(apply-scalar-monadic ,(cadadr functions)
							   (apply-scalar-monadic ,(cadar functions)
										 ,omega)))))))
	      (tests (is "a←⍴∘⍴ ◊ a 2 3 4⍴⍳9" #(3))))
	   )
 (functions (← (has :title "Assign")
	       (dyadic (macro (lambda (meta axes alpha omega)
	    			(let ((symbol (if (listp alpha)
						  (second alpha)
						  alpha)))
				  (if (or (eql 'lambda (first omega))
					  (and (listp (second omega))
					       (eql 'lambda (caadr omega))))
				      ;; assign from either a disclosed or enclosed function definition,
				      ;; i.e. a←⍴∘⍴ or a←(⍴∘⍴).
				      (setf (gethash :functions meta)
					    (cons symbol (gethash :functions meta))))
				  (if (and (listp (first omega))
					   (eq :fndef (caar omega)))
				      (progn (setf (gethash :functions meta)
						   (cons symbol (gethash :functions meta)))
					     `(setq ,symbol ,(second (funcall (caadar omega)
									      meta axes omega alpha))))
				      `(setq ,symbol ,omega))))))
	       (tests (is "x←55 ◊ 1+3 ◊ x" #(55))))
	    (⊣ (has :title "Left")
	       (ambivalent (args :any (lambda (omega)
	    				(declare (ignore omega))
	    				(make-array (list 0))))
	    		   (args :any :any (lambda (alpha omega)
	    				     (declare (ignore omega))
	    				     alpha)))
	       (tests (is "⊣77" #())
		      (is "55⊣77" #(55))))
	    (⊢ (has :title "Right")
	       (ambivalent (args :any (lambda (omega) omega))
	    		   (args :any :any (lambda (alpha omega)
	    				     (declare (ignore alpha))
	    				     omega)))
	       (tests (is "⊢77" #(77))
		      (is "55⊢77" #(77))))
	    (+ (has :titles ("Identity or Negate Imaginary" "Add"))
	       (ambivalent :asymmetric-scalar (lambda (omega) (if (complexp omega)
								  (complex (realpart omega)
									   (- (imagpart omega)))
								  omega))
			   +)
	       (tests (is "+5" #(5))
		      (is "+5J2" #(#C(5 -2)))
		      (is "1+1" #(2))
		      (is "1+1 2 3" #(2 3 4))))
    	    (- (has :titles ("Negate" "Subtract"))
	       (ambivalent :symmetric-scalar -)
	       (tests (is "2-1" #(1))
		      (is "7-2 3 4" #(5 4 3))))
     	    (× (has :titles ("Sign" "Multiply"))
	       (ambivalent :asymmetric-scalar signum *)
	       (tests (is "×20 5 0 ¯5 5 ¯9" #(1 1 0 -1 1 -1))
		      (is "2×3" #(6))
		      (is "4 5×8 9" #(32 45))))
     	    (÷ (has :titles ("Reciprocal" "Divide"))
	       (ambivalent :symmetric-scalar /)
	       (tests (is "6÷2" #(3))
		      (is "12÷6 3 2" #(2 4 6))
		      (is "÷2 4 8" #(1/2 1/4 1/8))))
     	    (⋆ (has :titles ("Exponential" "Power"))
	       (ambivalent :asymmetric-scalar exp expt)
	       (tests (is "⌊1000×⋆2" #(7389))
		      (is "2⋆4" #(16))
		      (is "⌊16⋆÷2" #(4))))
     	    (* (has :titles ("Exponential" "Power"))
	       (ambivalent :asymmetric-scalar exp expt))
     	    (⍟ (has :titles ("Natural Logarithm" "Logarithm"))
	       (ambivalent :asymmetric-scalar log (lambda (alpha omega) (log omega alpha)))
	       (tests (is "⌊1000×⍟5" #(1609))
		      (is "⌊2⍟8" #(3))))
     	    (\| (has :titles ("Magnitude" "Residue"))
	    	(ambivalent :asymmetric-scalar abs (lambda (alpha omega) (mod omega alpha)))
		(tests (is "|55" #(55))
		       (is "|¯33" #(33))
		       (is "8|39" #(7))))
     	    (! (has :titles ("Factorial" "Binomial"))
	       (ambivalent :asymmetric-scalar sprfact binomial)
	       (tests (is "!5" #(120))
		      (is "5!12" #(792))))
     	    (⌈ (has :titles ("Ceiling" "Maximum"))
	       (ambivalent :asymmetric-scalar ceiling max)
	       (tests (is "⌈1.0001" #(2))
		      (is "⌈1.9998" #(2))
		      (is "3⌈0 1 2 3 4 5" #(3 3 3 3 4 5))))
     	    (⌊ (has :titles ("Floor" "Minimum"))
	       (ambivalent :asymmetric-scalar floor min)
	       (tests (is "⌊1.0001" #(1))
		      (is "⌊1.9998" #(1))
		      (is "3⌊0 1 2 3 4 5" #(0 1 2 3 3 3))))
	    (? (has :titles ("Random" "Deal"))
	       (ambivalent (args :scalar (lambda (omega)
	    				   (+ (random omega)
	    				      (of-state *apex-idiom* :count-from))))
	    		   (args :one :one (lambda (alpha omega)
	    				     (make-array (list alpha)
	    						 :initial-contents
	    						 (loop for i from 0 to (1- alpha)
	    						    collect (+ (random omega)
	    							       (of-state *apex-idiom* :count-from))))))))
     	    (○ (has :titles ("Pi Times" "Circular"))
	       (ambivalent (args :scalar (lambda (omega) (* pi omega)))
	    		   (args :one :any (lambda (alpha omega)
	    				     (let ((fn (vector (lambda (input) (exp (* input #C(0 1))))
	    						       (lambda (input) (* input #C(0 1)))
	    						       (lambda (input) (if (complexp input)
	    									   (complex (realpart input)
	    										    (- (imagpart input)))
	    									   input))
	    						       (lambda (input) input)
	    						       (lambda (input) (expt (- -1 (* 2 input))
	    									     1/2))
	    						       #'atanh #'acosh #'asinh
	    						       (lambda (input) (* (expt (/ (1+ input) (1- input))
	    										1/2)
	    									  (1+ input)))
	    						       #'atan #'acos #'asin
	    						       (lambda (input) (expt (- 1 (* 2 input))
	    									     1/2))
	    						       #'sin #'cos #'tan
	    						       (lambda (input) (expt (1+ (* 2 input))
	    									     1/2))
	    						       #'sinh #'cosh #'tanh
	    						       (lambda (input) (expt (- -1 (* 2 input))
	    									     1/2))
	    						       #'realpart #'abs #'imagpart #'phase)))
	    				       ;; the twelfth element of the vector corresponds to
	    				       ;; index 0, hence an offset of 12 from the vector's first element
	    				       (apply-scalar-monadic (aref fn (+ 12 alpha))
								     omega)))))
	       (tests (is "⌊100000×○1" #(314159))
		      (is "(⌊1000×1÷2⋆÷2)=⌊1000×1○○÷4" #(1))))
	    (\~ (has :titles ("Not" "Excluding"))
	    	(ambivalent (args :scalar
				  (boolean-op (lambda (omega)
						(cond ((= 0 omega) t)
						      ((= 1 omega) nil)
						      (t (error
							  "Domain error: arguments to ~ must be 1 or 0."))))))
	    		    (args :any :any (lambda (alpha omega)
	    				      (let ((to-exclude (if (stringp omega)
	    							    (array-to-list omega)
	    							    (array-to-list (make-array
	    									    (list (array-total-size omega))
	    									    :displaced-to omega))))
	    					    (included nil))
	    					(aops:each (lambda (element)
	    						     ;;(print (list element to-exclude))
	    						     (if (not (member element to-exclude))
	    							 (setq included (cons element included))))
	    						   alpha)
	    					(make-array (list (length included))
	    						    :element-type (element-type alpha)
	    						    :initial-contents (reverse included))))))
	    	(tests (is "~1 0 1" #(0 1 0))
	    	       (is "1 2 3 4 5 6 7~3 5" #(1 2 4 6 7))
	    	       (is "'MACARONI'~'ALFREDO'" "MCNI")))
     	    (< (has :title "Less Than")
	       (dyadic (args :scalar (boolean-op <)))
	       (tests (is "3<1 2 3 4 5" #(0 0 0 1 1))))
     	    (≤ (has :title "Less or Equal")
	       (dyadic (args :scalar (boolean-op <=)))
	       (tests (is "3≤1 2 3 4 5" #(0 0 1 1 1))))
     	    (= (has :title "Equal")
	       (dyadic (args :scalar (boolean-op (lambda (alpha omega)
	    					   (cond ((and (numberp alpha)
	    						       (numberp omega))
	    						  (= alpha omega))
	    						 ((and (characterp alpha)
	    						       (characterp omega))
	    						  (char= alpha omega)))))))
	       (tests (is "3=1 2 3 4 5" #(0 0 1 0 0))))
     	    (≥ (has :title "Greater or Equal")
	       (dyadic (args :scalar (boolean-op >=)))
	       (tests (is "3≥1 2 3 4 5" #(1 1 1 0 0))))
     	    (> (has :title "Greater")
	       (dyadic (args :scalar (boolean-op >)))
	       (tests (is "3>1 2 3 4 5" #(1 1 0 0 0))))
     	    (≠ (has :title "Not Equal")
	       (dyadic (args :scalar (boolean-op /=)))
	       (tests (is "3≠1 2 3 4 5" #(1 1 0 1 1))))
	    (≡ (has :titles ("Depth" "Match"))
	       (ambivalent (args :any array-depth)
	    		   (args :any :any (boolean-op equalp))))
	    (≢ (has :title "Not Match")
	       (ambivalent (args :any (lambda (omega) (first (dims omega))))
	    		   ;; TODO: equalp is not exactly right for this function
	    		   (args :any :any (boolean-op (lambda (alpha omega) (not (equalp alpha omega)))))))
	    (^ (has :title "And")
	       (dyadic (args :scalar lcm))
	       (tests (is "0 1 0 1 ^ 0 0 1 1" #(0 0 0 1))))
	    (∧ (has :title "And")
	       (dyadic (args :scalar lcm))
	       (tests (is "0 1 0 1 ∧ 0 0 1 1" #(0 0 0 1))))
	    (⍲ (has :title "Nand")
	       (dyadic (args :scalar (boolean-op (lambda (alpha omega) (not (and (= alpha 1) (= omega 1)))))))
	       (tests (is "0 1 0 1 ⍲ 0 0 1 1" #(1 1 1 0))))
     	    (∨ (has :title "Or")
	       (dyadic (args :scalar gcd))
	       (tests (is "0 1 0 1 ∨ 0 0 1 1" #(0 1 1 1))))
	    (⍱ (has :title "Nor")
	       (dyadic (args :scalar (boolean-op (lambda (alpha omega) (and (= alpha 0) (= omega 0))))))
	       (tests (is "0 1 0 1 ⍱ 0 0 1 1" #(1 0 0 0))))
	    (⍳ (has :titles ("Index" "Index Of"))
	       (ambivalent (args :one (lambda (omega)
	    				(make-array (list omega)
	    					    :initial-contents
	    					    (mapcar (lambda (i)
	    						      (+ i (of-state *apex-idiom* :count-from)))
	    						    (alexandria:iota omega)))))
	    		   (args :any :any index-of))
	       (tests (is "⍳5" #(1 2 3 4 5))
	    	      (is "3⍳1 2 3 4 5" #(2 2 1 2 2))))
     	    (⍴ (has :titles ("Shape" "Reshape"))
	       (ambivalent (args :any (lambda (omega)
					(let ((omega-dims (dims omega)))
					  (make-array (list (length omega-dims))
						      :initial-contents omega-dims))))
	    		   (args :any :any (lambda (alpha omega)
	    				     (reshape-array-fitting omega (array-to-list alpha)))))
	       (tests (is "⍴1 2 3" #(3))
		      (is "⍴3 5⍴⍳8" #(3 5))
		      (is "4 5⍴⍳3" #2A((1 2 3 1 2) (3 1 2 3 1) (2 3 1 2 3) (1 2 3 1 2)))))
	    (∊ (has :titles ("Enlist" "Membership"))
	       (ambivalent (args :any enlist)
	    		   (args :any :any (lambda (alpha omega)
	    				     (let ((output (make-array (dims alpha))))
	    				       (dotimes (index (array-total-size output))
	    					 (let ((found nil))
	    					   (aops:each (lambda (input)
	    							(cond ((and (numberp input)
	    								    (numberp (row-major-aref alpha index))
	    								    (= input (row-major-aref alpha index)))
	    							       (setq found t))
	    							      ((and (characterp input)
	    								    (characterp
	    								     (row-major-aref alpha index))
	    								    (char= input
	    									   (row-major-aref alpha index)))
	    							       (setq found t))))
	    						      omega)
	    					   (setf (row-major-aref output index)
	    						 (if found 1 0))))
	    				       output))))
	       (tests (is "∊2 2 2⍴⍳9" #(1 2 3 4 5 6 7 8))
	    	      (is "2 5 7∊1 2 3 4 5" #(1 1 0))))
	    (↑ (has :titles ("Disclose" "Take"))
	       (ambivalent (args :any (lambda (omega)
	    				(if (or (not (vectorp omega))
	    					(not (arrayp (aref omega 0))))
	    				    omega (aref omega 0))))
	    		   (args :any :any :axes
	    			 (lambda (alpha omega &optional axes)
	    			   (multidim-slice omega (if axes
							     (loop for axis from 0 to (1- (rank omega))
								collect (if (= axis (- (aref (first axes) 0)
										       (of-state *apex-idiom*
												 :count-from)))
									    (aref alpha 0)
									    (nth axis (dims omega))))
							     (array-to-list alpha))
	    					   :fill-with 0))))
	       (tests (is "↑⊂1 2 3 4" #(1 2 3 4))
	    	      (is "2 3 4↑4 5 6⍴⍳9" #3A(((1 2 3 4) (7 8 9 1) (4 5 6 7))
	    				       ((4 5 6 7) (1 2 3 4) (7 8 9 1))))
		      (is "1↑[1]2 3 4⍴⍳9" #3A(((1 2 3 4) (5 6 7 8) (9 1 2 3))))
		      (is "1↑[2]2 3 4⍴⍳9" #3A(((1 2 3 4)) ((4 5 6 7))))
		      (is "2↑[2]2 3 4⍴⍳9" #3A(((1 2 3 4) (5 6 7 8)) ((4 5 6 7) (8 9 1 2))))
		      (is "2↑[3]2 3 4⍴⍳9" #3A(((1 2) (5 6) (9 1)) ((4 5) (8 9) (3 4))))))
	    (↓ (has :titles ("Drop" "Split"))
	       (ambivalent (args :any :axes (lambda (omega &optional axes)
	    				      ;; TODO: check this against another implementation
	    				      (aops:split omega (if axes (aref (first axes) 0)
	    							    (1- (rank omega))))))
	    		   (args :any :any :axes
	    			 (lambda (alpha omega &optional axes)
	    			   (multidim-slice omega
						   (if axes (loop for axis from 0 to (1- (rank omega))
							       collect (if (= axis (- (aref (first axes) 0)
										      (of-state *apex-idiom*
												:count-from)))
									   (aref alpha 0)
									   0))
						       (array-to-list alpha))
	    					   :inverse t))))
	       (tests (is "↓3 4⍴⍳9" #(#(1 2 3 4) #(5 6 7 8) #(9 1 2 3)))
	    	      (is "2 2 2↓4 5 6⍴⍳9" #3A(((3 4 5 6) (9 1 2 3) (6 7 8 9))
	    				       ((6 7 8 9) (3 4 5 6) (9 1 2 3))))
		      (is "1↓[1]2 3 4⍴⍳9" #3A(((4 5 6 7) (8 9 1 2) (3 4 5 6))))
		      (is "1↓[2]2 3 4⍴⍳9" #3A(((5 6 7 8) (9 1 2 3)) ((8 9 1 2) (3 4 5 6))))
		      (is "2↓[2]2 3 4⍴⍳9" #3A(((9 1 2 3)) ((3 4 5 6))))
		      (is "2↓[3]2 3 4⍴⍳9" #3A(((3 4) (7 8) (2 3)) ((6 7) (1 2) (5 6))))))
	    (⌷ (has :title "Axis")
	       (dyadic (args :any :any (lambda (alpha omega)
	    				 (let ((found (apply #'aref (cons omega
									  (mapcar (lambda (coord)
										    (- coord
										       (of-state *apex-idiom*
												 :count-from)))
										  (array-to-list alpha))))))
					   (if (not (arrayp found))
					       (vector found)
					       found)))))
	       (tests (is "3⌷⍳9" #(3))
		      (is "2 2⌷4 5⍴⍳9" #(7))
		      (is "2 3 4⌷4 5 6⍴⍳9" #(1))))
	    (\, (has :titles ("Ravel" "Catenate or Laminate"))
	    	(ambivalent (args :any (lambda (omega)
	    				 (if (vectorp omega)
	    				     omega (make-array (list (array-total-size omega))
							       :element-type (element-type omega)
	    						       :displaced-to (copy-array omega)))))
	    		    (args :any :any :axes
	    			  (lambda (alpha omega &optional axes)
	    			    (if (and (not axes)
	    				     (vectorp alpha)
	    				     (vectorp omega))
					;; TODO: improve handling of axis arguments when catenating vectors
	    				(concatenate 'vector alpha omega)
	    				(if (or (not axes)
						(integerp (aref (first axes) 0)))
					    (aops:stack (if axes (- (aref (first axes) 0)
								    (of-state *apex-idiom* :count-from))
							    1)
							alpha omega)
					    ;; laminate in the case of a fractional axis argument
					    ;; TODO: problems persist with laminate logic
					    (let ((axis (ceiling (- (aref (first axes) 0)
								    (of-state *apex-idiom* :count-from))))
						  (permute-dims (alexandria:iota (1+ (rank alpha)))))
					      (aops:stack axis
							  (aops:permute (rotate-right axis permute-dims)
									(array-promote alpha))
							  (aops:permute (rotate-right axis permute-dims)
									(array-promote omega)))))))))
	    	(tests (is ",3 4⍴⍳9" #(1 2 3 4 5 6 7 8 9 1 2 3))
	    	       (is "(3 6⍴⍳6),3 4⍴⍳9" #2A((1 2 3 4 5 6 1 2 3 4) (1 2 3 4 5 6 5 6 7 8)
	    					 (1 2 3 4 5 6 9 1 2 3)))
		       (is "(5 4⍴⍳6),[1]3 4⍴⍳9" #2A((1 2 3 4) (5 6 1 2) (3 4 5 6) (1 2 3 4)
						    (5 6 1 2) (1 2 3 4) (5 6 7 8) (9 1 2 3)))
		       (is "1 2 3 4,[0.5]1 2 3 4" #2A((1 2 3 4) (1 2 3 4)))
		       (is "1 2 3 4,[1.5]1 2 3 4" #2A((1 1) (2 2) (3 3) (4 4)))
		       (is "(2 3⍴⍳9),[0.5]2 3⍴⍳9" #3A(((1 2 3) (4 5 6)) ((1 2 3) (4 5 6))))
		       (is "(2 3⍴⍳9),[2.5]2 3⍴⍳9" #3A(((1 1) (2 2) (3 3)) ((4 4) (5 5) (6 6))))))
     	    (⍪ (has :titles ("Table" "Catenate First"))
	       (ambivalent (args :any (lambda (omega) (if (vectorp omega)
	    						  (make-array (list (length omega) 1)
								      :element-type (element-type omega)
	    							      :initial-contents
	    							      (loop for i from 0 to (1- (length omega))
	    								 collect (list (aref omega i))))
	    						  (let ((o-dims (dims omega)))
							    (make-array (list (first o-dims)
									      (apply #'* (rest o-dims)))
									:element-type (element-type omega)
									:displaced-to (copy-array omega))))))
	    		   (args :any :any :axes
				 (lambda (alpha omega &optional axes)
				   (if (and (vectorp alpha)
					    (vectorp omega))
				       (if axes
					   (error "Axis arguments not accepted when catenating vectors.")
					   (concatenate 'vector alpha omega))
				       (aops:stack (if axes (- (aref (first axes) 0)
							       (of-state *apex-idiom* :count-from))
						       0)
						   alpha omega)))))
	       (tests (is "⍪'MAKE'" #2A((#\M) (#\A) (#\K) (#\E)))
		      (is "⍪3 4⍴⍳9" #2A((1 2 3 4) (5 6 7 8) (9 1 2 3)))
		      (is "⍪2 3 4⍴⍳24" #2A((1 2 3 4 5 6 7 8 9 10 11 12)
					   (13 14 15 16 17 18 19 20 21 22 23 24)))
	    	      (is "(5 4⍴⍳6)⍪3 4⍴⍳9" #2A((1 2 3 4) (5 6 1 2) (3 4 5 6) (1 2 3 4)
	    					(5 6 1 2) (1 2 3 4) (5 6 7 8) (9 1 2 3)))
		      (is "(3 6⍴⍳6)⍪[2]3 4⍴⍳9" #2A((1 2 3 4 5 6 1 2 3 4) (1 2 3 4 5 6 5 6 7 8)
						   (1 2 3 4 5 6 9 1 2 3)))))
	    (/ (has :title "Compress")
	       (dyadic (args :any :any :axes
	    		     (lambda (alpha omega &optional axes)
	    		       (expand-array (array-to-list alpha)
	    				     omega (if axes (- (rank omega)
	    						       (- (aref (first axes) 0)
	    							  (1- (of-state *apex-idiom* :count-from)))))
	    				     0 :compress-mode t))))
	       (tests (is "5/3" #(3 3 3 3 3))
		      (is "1 0 1 0 1/⍳5" #(1 3 5))
		      (is "3/⍳5" #(1 1 1))
		      (is "3/⊂⍳5" #(#(1 2 3 4 5) #(1 2 3 4 5) #(1 2 3 4 5)))
	    	      (is "1 ¯2 3 ¯4 5/3 5⍴⍳5" #2A((1 0 0 3 3 3 0 0 0 0 5 5 5 5 5)
						   (1 0 0 3 3 3 0 0 0 0 5 5 5 5 5)
						   (1 0 0 3 3 3 0 0 0 0 5 5 5 5 5)))
		      (is "1 ¯2 3/[1]3 5⍴⍳9" #2A((1 2 3 4 5) (0 0 0 0 0) (0 0 0 0 0)
						 (2 3 4 5 6) (2 3 4 5 6) (2 3 4 5 6)))))
	    (⌿ (has :title "Compress First")
	       (dyadic (args :any :any :axes
	    		     (lambda (alpha omega &optional axes)
	    		       (expand-array (array-to-list alpha)
	    				     omega (if axes (- (rank omega)
	    						       (- (aref (first axes) 0)
	    							  (1- (of-state *apex-idiom* :count-from)))))
	    				     (1- (rank omega))
	    				     :compress-mode t))))
	       (tests (is "1 0 1 0 1⌿⍳5" #(1 3 5))
		      (is "1 ¯2 3⌿3 5⍴⍳9" #2A((1 2 3 4 5) (0 0 0 0 0) (0 0 0 0 0)
					      (2 3 4 5 6) (2 3 4 5 6) (2 3 4 5 6)))
		      (is "1 ¯2 3 ¯4 5⌿[2]3 5⍴⍳5" #2A((1 0 0 3 3 3 0 0 0 0 5 5 5 5 5)
						      (1 0 0 3 3 3 0 0 0 0 5 5 5 5 5)
						      (1 0 0 3 3 3 0 0 0 0 5 5 5 5 5)))))
	    (\\ (has :title "Expand")
	    	(dyadic (args :any :any :axes
	    		      (lambda (alpha omega &optional axes)
	    			(expand-array (array-to-list alpha)
	    				      omega (if axes (- (rank omega)
	    							(- (aref (first axes) 0)
	    							   (1- (of-state *apex-idiom* :count-from)))))
	    				      0))))
		(tests (is "1 ¯2 3 ¯4 5\\ '.'" ".  ...    .....")
		       (is "1 ¯2 2 0 1\\3+2 3 ⍴⍳6" #2A((4 0 0 5 5 0 6) (7 0 0 8 8 0 9)))
		       (is "1 0 1\\[1]3+2 3 ⍴⍳6" #2A((4 5 6) (0 0 0) (7 8 9)))))
	    (⍀ (has :title "Expand First")
	       (dyadic (args :any :any :axes
	    		     (lambda (alpha omega &optional axes)
	    		       (expand-array (array-to-list alpha)
	    				     omega (if axes (- (rank omega)
	    						       (- (aref (first axes) 0)
	    							  (1- (of-state *apex-idiom* :count-from)))))
	    				     (1- (rank omega))))))
	       (tests (is "1 ¯2 3 ¯4 5⍀3" #(3 0 0 3 3 3 0 0 0 0 3 3 3 3 3))
		      (is "1 0 1⍀3+2 3 ⍴⍳6" #2A((4 5 6) (0 0 0) (7 8 9)))))
	    (⍷ (has :title "Find")
	       (dyadic (args :any :any find-array))
	       (tests (is "(2 2⍴6 7 1 2)⍷2 3 4⍴⍳9" #3A(((0 0 0 0) (0 1 0 0) (0 0 0 0))
						       ((0 0 1 0) (0 0 0 0) (0 0 0 0))))))
	    (⊂ (has :titles ("Enclose" "Partition"))
	       ;; TODO: add multi-axis option
	       (ambivalent (args :any :axes
				 (lambda (omega &optional axes)
				   (if axes
				       (aops:split (aops:permute (sort (alexandria:iota (rank omega))
								       (lambda (a b)
									 (declare (ignore a))
									 (= b (- (aref (first axes) 0)
										 (of-state *apex-idiom*
											   :count-from)))))
								 omega)
						   (1- (rank omega)))
				       (if (loop for dim in (dims omega) always (= 1 dim))
					   omega (make-array (list 1) :initial-element omega)))))
	    		   (args :any :any (lambda (alpha omega)
	    				     (if (/= (length alpha) (length omega))
	    					 (error "Length mismatch.")
	    					 (let ((output nil)
	    					       (accumulator nil)
	    					       (partition-index 0))
	    					   (dotimes (index (length alpha))
	    					     (if (and (< 0 index)
	    						      (< partition-index (aref alpha index)))
	    						 (progn (setq output
	    							      (cons (make-array (list (length accumulator))
	    										:initial-contents
	    										(reverse accumulator))
	    								    output))
	    							(setq accumulator nil)))
	    					     (setq partition-index (aref alpha index))
	    					     (if (< 0 (aref alpha index))
	    						 (setq accumulator (cons (aref omega index)
	    									 accumulator))))
	    					   (if accumulator (setq output
	    								 (cons (make-array
	    									(list (length accumulator))
	    									:initial-contents
	    									(reverse accumulator))
	    								       output)))
	    					   (make-array (list (length output))
	    						       :initial-contents (reverse output)))))))
	       (tests (is "⊂3 4⍴⍳7" #(#2A((1 2 3 4) (5 6 7 1) (2 3 4 5))))
		      (is "⊂[3]2 3 4⍴'GRAYGOLDBLUESILKWOOLYARN'"
			  #2A(("GRAY" "GOLD" "BLUE") ("SILK" "WOOL" "YARN")))
		      (is "⊂[2]2 3 4⍴'GRAYGOLDBLUESILKWOOLYARN'"
			  #2A(("GGB" "ROL" "ALU" "YDE") ("SWY" "IOA" "LOR" "KLN")))
		      (is "⊂[1]2 3 4⍴'GRAYGOLDBLUESILKWOOLYARN'"
			  #2A(("GS" "RI" "AL" "YK") ("GW" "OO" "LO" "DL") ("BY" "LA" "UR" "EN")))
	    	      (is "1 1 2 2 2 3 3 3 3⊂⍳9" #(#(1 2) #(3 4 5) #(6 7 8 9)))))
	    (⊃ (has :titles ("Mix" "Pick"))
	       (ambivalent (args :any :axes
				 (lambda (omega &optional axes)
				   (mix-arrays (if axes (ceiling (- (1+ (rank omega))
								    (aref (first axes) 0)
								    (of-state *apex-idiom* :count-from)))
						   0)
					       omega)))
	    		   (args :any :any (lambda (alpha omega)
					     (labels ((layer-index (object indices)
							(if indices
							    (layer-index (aref object (- (first indices)
											 (of-state *apex-idiom*
												   :count-from)))
									 (rest indices))
							    object)))
					       (let ((found (layer-index omega (array-to-list alpha))))
						 (if (arrayp found)
						     found (make-array (list 1)
								       :element-type (element-type omega)
								       :initial-element found)))))))
	       (tests (is "⊃(1)(1 2)(1 2 3)" #2A((1 0 0) (1 2 0) (1 2 3)))
		      (is "⊃[0.5](1)(1 2)(1 2 3)" #2A((1 1 1) (0 2 2) (0 0 3)))
		      (is "⊃(2 3⍴⍳5)(4 2⍴⍳8)" #3A(((1 2 3) (4 5 1) (0 0 0) (0 0 0))
						  ((1 2 0) (3 4 0) (5 6 0) (7 8 0))))
		      (is "⊃[0.5](2 3⍴⍳5)(4 2⍴⍳8)" #3A(((1 4 0 0) (1 3 5 7)) ((2 5 0 0) (2 4 6 8))
						       ((3 1 0 0) (0 0 0 0))))
		      (is "⊃[1.5](2 3⍴⍳5)(4 2⍴⍳8)" #3A(((1 2 3) (4 5 1) (0 0 0) (0 0 0))
						       ((1 2 0) (3 4 0) (5 6 0) (7 8 0))))
		      (is "⊃2 2 2⍴(1)(1 2)(3 4)(1 2 3)" #4A((((1 0 0) (1 2 0)) ((3 4 0) (1 2 3)))
							    (((1 0 0) (1 2 0)) ((3 4 0) (1 2 3)))))
		      (is "2⊃(1 2 3)(4 5 6)(7 8 9)" #(4 5 6))
		      (is "(2 2)⊃(1 2 3)(4 5 6)(7 8 9)" #(5))))
	    (∪ (has :titles ("Unique" "Union"))
	       (ambivalent (args :any (lambda (omega)
	    				(if (not (vectorp omega))
	    				    (error "Argument must be a vector.")
	    				    (let ((uniques nil))
	    				      (dotimes (index (length omega))
	    					(if (not (find (aref omega index)
	    						       uniques))
	    					    (setq uniques (cons (aref omega index)
	    								uniques))))
	    				      (make-array (list (length uniques))
							  :element-type (element-type omega)
	    						  :initial-contents (reverse uniques))))))
	    		   (args :any :any (lambda (alpha omega)
	    				     (if (or (not (vectorp alpha))
	    					     (not (vectorp omega)))
	    					 (error "Arguments must be vectors.")
	    					 (let ((uniques nil))
	    					   (dotimes (index (length omega))
	    					     (if (not (find (aref omega index)
	    							    alpha))
	    						 (setq uniques (cons (aref omega index)
	    								     uniques))))
	    					   (concatenate 'vector alpha
	    							(make-array (list (length uniques))
									    :element-type (element-type alpha)
	    								    :initial-contents
	    								    (reverse uniques))))))))
	       (tests (is "∪1 2 3 4 5 1 2 8 9 10 11 7 8 11 12" #(1 2 3 4 5 8 9 10 11 7 12))
		      (is "∪'MISSISSIPPI'" "MISP")
		      ;; TODO: is behavior below correct?
		      (is "3 10 14 18 11∪9 4 5 10 8 3" #(3 10 14 18 11 9 4 5 8))
		      (is "'STEEL'∪'SABER'" "STEELABR")))
	    (∩ (has :title "Intersection")
	       (dyadic (args :any :any (lambda (alpha omega)
	    				 (if (or (not (vectorp alpha))
	    					 (not (vectorp omega)))
	    				     (error "Arguments must be vectors.")
	    				     (let ((matches nil))
	    				       (dotimes (index (length alpha))
	    					 (if (find (aref alpha index)
	    						   omega)
	    					     (setq matches (cons (aref alpha index)
	    								 matches))))
	    				       (make-array (list (length matches))
							   :element-type (element-type alpha)
	    						   :initial-contents (reverse matches)))))))
	       (tests (is "'MIXTURE'∩'LATER'" "TRE")
		      (is "'STEEL'∩'SABER'" "SEE")
		      (is "1 4 8∩⍳5" #(1 4))))
	    (⌽ (has :titles ("Reverse" "Rotate"))
	       (ambivalent (args :any :axes (lambda (omega &optional axes)
	    				      (if (vectorp omega)
	    					  (let ((new-array (copy-array omega)))
	    					    (funcall (make-rotator)
	    						     new-array)
	    					    new-array)
	    					  (if (arrayp omega)
	    					      (apply-marginal (make-rotator)
	    							      omega (if axes (1- (aref (first axes) 0)))
	    							      (1- (rank omega)))))))
	    		   (args :one :any :axes
	    			 (lambda (alpha omega &optional axes)
	    			   (if (vectorp omega)
	    			       (let ((new-array (copy-array omega)))
	    				 (funcall (make-rotator alpha)
	    					  new-array)
	    				 new-array)
	    			       (if (arrayp omega)
	    				   (apply-marginal (make-rotator alpha)
	    						   omega (if axes (1- (aref (first axes) 0)))
	    						   (1- (rank omega))))))))
	       (tests (is "⌽1 2 3 4 5" #(5 4 3 2 1))
	    	      (is "⌽3 4⍴⍳9" #2A((4 3 2 1) (8 7 6 5) (3 2 1 9)))
	    	      (is "2⌽3 4⍴⍳9" #2A((3 4 1 2) (7 8 5 6) (2 3 9 1)))))
     	    (⊖ (has :titles ("Reverse First" "Rotate First"))
	       (ambivalent (args :any :axes (lambda (omega &optional axes)
	    				      (if (vectorp omega)
	    					  (let ((new-array (copy-array omega)))
	    					    (funcall (make-rotator)
	    						     new-array)
	    					    new-array)
	    					  (if (arrayp omega)
	    					      (apply-marginal (make-rotator)
	    							      omega (if axes (1- (aref (first axes) 0)))
	    							      0)))))
	    		   (args :one :any :axes
	    			 (lambda (alpha omega &optional axes)
	    			   (if (vectorp omega)
	    			       (let ((new-array (copy-array omega)))
	    				 (funcall (make-rotator alpha)
	    					  new-array)
	    				 new-array)
	    			       (if (arrayp omega)
	    				   (apply-marginal (make-rotator alpha)
	    						   omega (if axes (1- (aref (first axes) 0)))
	    						   0))))))
	       (tests (is "⊖1 2 3 4 5" #(5 4 3 2 1))
	    	      (is "⊖3 4⍴⍳9" #2A((9 1 2 3) (5 6 7 8) (1 2 3 4)))
	    	      (is "1⊖3 4⍴⍳9" #2A((5 6 7 8) (9 1 2 3) (1 2 3 4)))))
	    (⍉ (has :titles ("Transpose" "Permute"))
	       (ambivalent (args :any (lambda (omega)
	    				(aops:permute (reverse (alexandria:iota (rank omega)))
	    					      omega)))
	    		   (args :any :any (lambda (alpha omega)
	    				     (aops:permute (mapcar (lambda (i)
	    							     (- i (of-state *apex-idiom* :count-from)))
	    							   (array-to-list alpha))
	    						   omega))))
	       (tests (is "⍉2 3 4⍴⍳9" #3A(((1 4) (5 8) (9 3)) ((2 5) (6 9) (1 4))
					  ((3 6) (7 1) (2 5)) ((4 7) (8 2) (3 6))))
		      (is "1 3 2⍉2 3 4⍴⍳9" #3A(((1 5 9) (2 6 1) (3 7 2) (4 8 3))
					       ((4 8 3) (5 9 4) (6 1 5) (7 2 6))))))
	    (⍋ (has :titles ("Grade Up" "Grade Up By"))
	       (ambivalent (args :any (lambda (omega) (grade omega (alpha-compare (of-state *apex-idiom*
	    										    :atomic-vector)
	    									  #'<=)
							     (of-state *apex-idiom* :count-from))))
	    		   (args :any :any (lambda (alpha omega) (grade (if (vectorp alpha)
									    (index-of alpha omega)
									    (array-grade alpha omega))
	    								(alpha-compare (of-state *apex-idiom*
	    											 :atomic-vector)
	    									       #'<)
									(of-state *apex-idiom* :count-from)))))
	       (tests (is "⍋8 3 4 9 1 5 2" #(5 7 2 3 6 1 4))
		      (is "⍋5 6 ⍴⍳16" #(1 4 2 5 3))
		      (is "(2 5⍴'ABCDEabcde')⍋'ACaEed'" #(1 3 2 6 4 5))))
	    (⍒ (has :titles ("Grade Down" "Grade Down By"))
	       (ambivalent (args :any (lambda (omega) (grade omega (alpha-compare (of-state *apex-idiom*
	    										    :atomic-vector)
	    									  #'>=)
							     (of-state *apex-idiom* :count-from))))
	    		   (args :any :any (lambda (alpha omega) (grade (if (vectorp alpha)
									    (index-of alpha omega)
									    (array-grade alpha omega))
	    								(alpha-compare (of-state *apex-idiom*
	    											 :atomic-vector)
	    									       #'>)
									(of-state *apex-idiom* :count-from)))))
	       (tests (is "⍒6 1 8 2 4 3 9" #(7 3 1 5 6 4 2))
		      (is "⍒5 6 ⍴⍳12" #(2 4 1 3 5))
		      (is "(2 5⍴'ABCDEabcde')⍒'ACaEed'" #(5 4 6 2 3 1))))
	    ;; TODO: inversion does not yet work for non-square matrices
	    (⌹ (has :titles ("Matrix Inverse" "Matrix Divide"))
	       (ambivalent (args :any (lambda (omega)
	    				(if (and (= 1 (rank omega))
	    					 (= 1 (length omega)))
	    				    (/ (aref omega 0))
	    				    (invert-matrix omega))))
	    		   (args :any :any (lambda (alpha omega)
					     (array-inner-product (invert-matrix omega)
								  alpha (lambda (arg1 arg2)
									  (apply-scalar-dyadic #'* arg1 arg2))
								  #'+))))
	       (tests (is "⌹2 2⍴4 9 8 2" #2A((-1/32 9/64) (1/8 -1/16)))
		      (is "35 89 79⌹3 3⍴3 1 4 1 5 9 2 6 5" #(193/90 739/90 229/45))
		      (is "(3 2⍴1 2 3 6 9 10)⌹3 3⍴1 0 0 1 1 0 1 1 1" #2A((1 2) (2 4) (6 4)))))
	    (⊤ (has :title "Encode")
	       (dyadic (args :any :any (lambda (alpha omega)
	    				 (flet ((rebase (bases number)
	    					  (let ((operand number)
	    						(last-base 1)
	    						(base 1)
	    						(component 1)
	    						(element nil))
	    					    (loop for index from (1- (length bases)) downto 0
	    					       do (setq last-base base
	    							base (* base (aref bases index))
	    							component (if (= 0 base)
	    								      operand
	    								      (* base
	    									 (nth-value 1 (floor (/ operand
	    												base)))))
	    							operand (- operand component)
	    							element (/ component last-base))
	    					       collect element))))
	    				   (if (= 1 (length omega))
	    				       (let ((result (rebase alpha (aref omega 0))))
	    					 (make-array (list (length result))
	    						     :initial-contents (reverse result)))
	    				       (aops:permute (list 1 0)
	    						     (make-array (list (length omega) (length alpha))
	    								 :initial-contents
	    								 (mapcar (lambda (item)
	    									   (reverse (rebase alpha item)))
	    									 (array-to-list omega)))))))))
	       (tests (is "1760 3 12⊤82" #(2 0 10))
		      (is "16 16 16 16⊤100" #(0 0 6 4))
		      (is "2 2 2 2 2⊤1 2 3 4 5" #2A((0 0 0 0 0) (0 0 0 0 0) (0 0 0 1 1)
						    (0 1 1 0 0) (1 0 1 0 1)))))
	    (⊥ (has :title "Decode")
	       (dyadic (args :any :any (lambda (alpha omega)
	    				 (flet ((rebase (bases numerators)
	    					  (let ((result 0)
	    						(base 1))
	    					    (loop for index from (1- (length numerators)) downto 0
	    					       do (incf result (* base (aref numerators index)))
	    						 (setf base (* base (aref bases index))))
	    					    result)))
	    				   (let ((bases (if (= 1 (length alpha))
	    						    (make-array (list (first (dims omega)))
	    								:initial-element (aref alpha 0))
	    						    (if (not (= (length alpha)
	    								(let ((d-o (dims omega)))
	    								  (if (= 1 (length d-o))
	    								      (first d-o)
	    								      (second d-o)))))
	    							(error "Base/element length mismatch.")
	    							alpha))))
	    				     (if (= 1 (rank omega))
	    					 (vector (rebase bases omega))
	    					 (aops:margin (lambda (sub-array) (rebase bases sub-array))
	    						      omega 0)))))))
	       (tests (is "10⊥2 6 7 1" #(2671))
		      (is "1760 3 12⊥2 2 5" #(101))
		      (is "1760 3 12⊥3 3⍴1 2 1 5 0 2 2 3 7" #(98 75 67))))
	    (⍎ (has :title "Evaluate")
	       (monadic (macro (lambda (meta axes omega)
				 (declare (ignore meta axes))
				 `(apex ,omega))))
	       (tests (is "⍎'1+1'" #(2))))
	    (∘ (has :title "Find Outer Product, Not Inner")
	       (symbolic :outer-product-designator)))
 (general-tests (with :title "Basic function definition and use, with comments."
		      :in ("⍝ This code starts with a comment.
                            f1←{⍵+3} ◊ f2←{⍵×2} ⍝ A comment after the functions are defined.
                            ⍝ This is another comment.
                            f2 f1 1 2 3 4 5")
		      :ex #(8 10 12 14 16))
		(with :title "Monadic inline function."
		      :in ("{⍵+3} 3 4 5")
		      :ex #(6 7 8))
		(with :title "Dyadic inline function."
		      :in ("1 2 3 {⍺×⍵+3} 3 4 5")
		      :ex #(6 14 24))))
